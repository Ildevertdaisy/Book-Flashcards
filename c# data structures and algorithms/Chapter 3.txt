#1

Arrays and Sorting
As a developer, you have certainly stored various collections within your applications, such as data of users, books, and logs. One of the natural ways of storing such data is by using arrays. However, have you ever thought about their variants? For example, have you heard about jagged arrays? In this chapter, you will see arrays in action, together with examples and detailed descriptions.

#2

You can use an array to store many items of the same type, such as int, string, as well as a user-defined class or record. Just keep in mind that the number of elements in an array cannot be changed after initialization. For this reason, you will not be able to easily add a new item at the end of the array or insert an element in a given position within the array while moving the remaining items one position further. If you need such features, you can use another data structure, namely a list and its variants, which will be described in the following chapter.

#3

While developing applications in the C# language, you can benefit from a few variants of arrays, namely single-dimensional arrays, multi-dimensional arrays, and jagged arrays. In this chapter, you will also get to know seven sorting algorithms, namely selection sort, insertion sort, bubble sort, merge sort, Shell sort, quicksort, and heap sort. For each, you will see an illustration-based example, the implementation code, and a step-by-step explanation. You will also see their performance analysis, presented with charts.

#4

We will cover the following topics in this chapter:

- Single-dimensional arrays
- Multi-dimensional arrays
- Jagged arrays
- Sorting algorithms

#5

Single-dimensional arrays
Let’s start with the simplest variant of arrays, namely single-dimensional ones. Such an array stores a collection of items of the same type, which are accessible by an index. It is important to remember that indices of elements within arrays in C# are zero-based. This means that the first element has an index equal to 0, while the last one has an index equal to the length of the array minus one.

#6

Imagine a single-dimensional array

If you want to better imagine a single-dimensional array, take your eyes off this book for a moment and look at the chest of drawers or wardrobe in your room. A standard chest of drawers consists of several drawers and a single-dimensional array looks similar. It also has several elements (as drawers), which are accessible via the index. You cannot change the size of the array in the same way as you cannot change the number of drawers since the furniture is prepared. An array has one significant advantage over a chest of drawers, namely all its “drawers” are always working as expected.

#7

An example of a single-dimensional array is shown in the following figure:

Figure 3.1 – Example of a single-dimensional array

It contains five elements with the following values: 9, -11, 6, -12, and 1. The first element has an index equal to 0, while the last one has an index equal to 4.

To use a single-dimensional array, you need to declare and initialize it. The declaration is very simple because you just need to specify a type of element and a name, as follows:

type[] name;

#8

The declaration of an array with integer values is shown in the following line:
int[] numbers;

So far, you know how to declare an array, but what about initializing one? To create an array with five elements and initialize them to default values, you can use the new operator, as shown here:
numbers = new int[5];

#9

Of course, you can combine a declaration and initialization in the same line, as follows:

int[] numbers = new int[5];

Unfortunately, all the elements currently have default values – that is, zeros in the case of integer values. Thus, you need to set the values of particular elements. You can do this using the [] operator and an index of an element, as shown in the following code:

numbers[0] = 9;
numbers[1] = -11;
numbers[2] = 6;
numbers[3] = -12;
numbers[4] = 1;

#10

Moreover, you can combine a declaration and initialization of array elements to specific values using one of the following variants:

int[] numbers = new int[] { 9, -11, 6, -12, 1 };
int[] numbers = { 9, -11, 6, -12, 1 };

Another approach involves using the collection expression, as follows:

int[] numbers = [9, -11, 6, -12, 1];

#11

When you have the proper values of elements within an array, you can get values using the [] operator and by specifying the index, as shown in the following line of code:

int middle = numbers[2];

Here, you get a value of the third element (the index equal to 2) from the numbers array and store it as a value of the middle variable.

#12

The array has some properties that can be useful while developing applications. For example, the Length property makes it possible to get the size of the array, namely the number of elements stored within it. If you want to access the last item in the array, regardless of its size, you can use the following line of code:

int last = numbers[numbers.Length - 1];

You can simplify this with the index operator, as follows:

int last = numbers[^1];

It is worth noting that the second item from the end can be received by [^2], the third by [^3], and so on.

#13

The other property is named Rank and returns the number of dimensions of the array. Usage of this property is shown in the following line of code:

int rank = numbers.Rank;

Apart from the already mentioned properties, you can use a set of static methods of the Array class, such as Exists, to check whether there is any element in the array that matches the given predicate. For example, you can easily verify whether the array contains any element whose value is greater than zero, as follows:

bool anyPositive = Array.Exists(numbers, e => e > 0);

#14

Among other methods, you can use TrueForAll to check whether all elements meet the provided predicate, such as to ensure that there are no zeros in the array:

bool noZeros = Array.TrueForAll(numbers, e => e != 0);

#15

You can also get the first element that matches the predicate. As an example, let’s get the value of the first number that is smaller than zero using the Find method:

int firstNegative = Array.Find(numbers, e => e < 0);

If you want to get a new array with all the elements that meet the given condition, you can use the FindAll method. The following code shows how to get all negative numbers:

int[] negatives = Array.FindAll(numbers, e => e < 0);

#16

When you do not want to specify the predicate and you just want to check whether the array contains a given element or not, you can use the IndexOf method, which returns an index of the first found occurrence of the value or -1, if not found:

int index = Array.IndexOf(numbers, -12);

Another interesting static method is ForEach. It allows you to perform some operations for all the elements in the array. As an example, you can use it to write the absolute value of each array element in the console, as shown in the following code:

Array.ForEach(numbers, 
    e => Console.WriteLine(Math.Abs(e)));

#17

As you can see, even for as simple a data structure as a single-dimensional array, you have a lot of useful built-in features. Let’s continue learning them and take a look at the two next methods, namely Reverse and Sort. According to their names, the first allows you to reverse the order of the elements, either for the whole array or only within some range. This is presented in the following line of code, which reverses the first three elements:

Array.Reverse(numbers, 0, 3);

#18

The Sort method has even more variants. In its simplest form, it sorts the whole array. After running the following line, you’ll get the array with the elements sorted from the smallest to the biggest:

Array.Sort(numbers);

#19

If you want to fill the whole array with the same value or fill the range of elements with the same value, you can use a for loop and simply iterate through suitable indices and assign a given value. However, you can use the Fill method instead. The following line places 3 as a value of all elements in the array:

Array.Fill(numbers, 3);

#20

Another method we can use is Clear, which makes it possible to clear the whole array or a range of its elements. For example, you can fill the whole array with the default value of the integer type, namely zeros, using the following line of code:

Array.Clear(numbers);

#21

Now, let’s take a look at Copy, which copies a range of elements from the source array to the destination array. You can use one out of a few variants, such as to specify indices from both arrays. As an example, let’s copy 3 elements (specified as length) from the numbers array (as the source array), starting from the first element (source index set to 0), and place them in the subarray array, starting from the first element (destination index set to 0):

int[] subarray = new int[3];
Array.Copy(numbers, 0, subarray, 0, 3);

We’ve already covered a few available properties and methods, but it is worth mentioning some extension methods as well, such as Contains and Max.


#22

Have you ever heard about extension methods?

If not, think of them as methods that are “added” to a particular existing type (both built-in or user-defined) and can be called in the same way as when they are defined directly as instance methods. The declaration of an extension method requires you to specify it within a static class as a static method with the first parameter indicating the type to which you want to “add” this method with the this keyword.

#23

You can use the Contains extension method to check whether the array contains an element passed as the parameter. As an example, let’s learn how to ensure that the numbers array contains 6 as one of its elements:

bool contains = numbers.Contains(6);

#24

The Contains method is not the only available extension method. Among others, you can find All and Any. The first (All) checks whether all of the elements match the given predicate, while the other (Any) verifies whether at least one element meets the condition. You can use them to ensure that there are no zeros in the array and check whether there is at least one positive element, as shown here:

bool noZeros = numbers.All(n => n != 0);
bool anyPositive = numbers.Any(n => n > 0);

#25

What will you do to find the minimum or maximum value in the array? You will probably iterate through all elements and check whether each element is smaller (for searching the minimum) or bigger (in the case of the maximum) than the already found minimum or maximum value. If that is your solution, you are correct and it is a good way of solving the problem. However, you can make your code much shorter by using the Min and Max extension methods, as shown here:

int min = numbers.Min();
int max = numbers.Max();

#26

Pretty simple, isn’t it? Let’s also take a look at the Average and Sum methods, which easily calculate the average value of all of the elements, as well as their sum:

double avg = numbers.Average();
int sum = numbers.Sum();

After this short introduction to single-dimensional arrays, it’s high time to take a look at an example of how to apply such arrays in real-world scenarios.

#27

Where can you find more information?

You can find a lot of interesting information about arrays and their various variants in the context of the C# language at https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/.

#28

Example – month names
To summarize what you’ve learned about single-dimensional arrays, let’s use an array to store names of months, written in English. Such names should be obtained automatically, not by hardcoding them in the code.

The implementation is shown here:

using System.Globalization;
CultureInfo culture = new("en");
string[] months = new string[12];
for (int month = 1; month <= 12; month++)
{
    DateTime firstDay = new(DateTime.Now.Year, month, 1);
    string name = firstDay.ToString("MMMM", culture);
    months[month - 1] = name;
}
foreach (string m in months)
{
    Console.WriteLine(m);
}


#29

First, you create a new instance of the CultureInfo class (from the System.Globalization namespace), passing en as a parameter, to later get the names of months in English. Then, you declare a new single-dimensional array and initialize it with default values. It contains 12 elements to store the names of all the months in a year. Then, the for loop is used to iterate through the numbers of all months – that is, from 1 to 12. For each of them, a DateTime instance representing the first day in a particular month from the current year is created.

#30

The name of the month is obtained by calling the ToString method on the DateTime instance, passing the proper format of the date (MMMM), as well as specifying the culture. Then, the name is stored in the array using the [] operator and an index of the element. It is worth noting that the index is equal to the current value of the month variable minus one. Such subtraction is necessary because the first element in the array has an index equal to zero, instead of one.

#31

The next interesting part of the code is the foreach loop, which iterates through all elements of the array. For each of them, the name of the month is shown in the console:

January
February (...)
December

As mentioned earlier, single-dimensional arrays are not the only available variant. You will learn more about multi-dimensional arrays in the following section.


#32

Multi-dimensional arrays
The arrays in the C# language do not need to have only one dimension. It is possible to create two-dimensional arrays as well. As you will see, multi-dimensional arrays are very useful and are frequently used while developing various applications.


#33

Imagine a two-dimensional array

If you want to imagine a two-dimensional array, take a break, close your eyes, and play Sudoku. If you don’t know what this is, Sudoku is a popular game that requires you to fill empty cells of a 9x9 board with numbers from 1 to 9. However, each row, each column, and each 3x3 box can only contain unique numbers. Surprise – this board forms a two-dimensional array! You can point to any place on the board by specifying its row and column, the same as in the case of a two-dimensional array. And if you are a bit tired of solving such puzzles with a pencil and a piece of paper, take a look at Chapter 9, See in Action, where you will learn how to create an algorithm for solving a Sudoku puzzle!

An example two-dimensional array that stores integer values is shown here:

Figure 3.2 – Example of a two-dimensional array


#34

First, you need to declare and initialize a two-dimensional array with 5 rows and 3 columns, as shown in the following line of code:

int[,] numbers = new int[5, 3];
numbers[0, 0] = 9; (...)

You can combine a declaration with an initialization in a bit different way as well:

int[,] numbers = new int[,]
{ 
    { 9, 5, -9 }, 
    { -11, 4, 0 }, 
    { 6, 115, 3 }, 
    { -12, -9, 71 }, 
    { 1, -6, -1 } 
};

#35

A small explanation is necessary for the way you access particular elements from a two-dimensional array. Let’s take a look at the following example:

int number = numbers[2, 1];
numbers[1, 0] = 11;

In the first line of code, the value from the third row (index equal to 2) and second column (index equal to 1) is obtained (that is, 115) and set as a value of the number variable. The other line replaces -11 with 11 in the second row and the first column.

Now that you’ve learned about one-dimensional and two-dimensional arrays, let’s proceed to three-dimensional ones. Do you know how to understand this structure?

#36

Imagine a three-dimensional array

If you want to better imagine a three-dimensional array, launch a game in which you can create buildings from blocks. You place each of them in a specified location on the board, in X and Y coordinates. However, you can also build the next building floors, so you can specify the block’s Z coordinate as well. In such circumstances, you operate in a three-dimensional world with three-dimensional arrays!

An example three-dimensional array is presented in the following figure:

Figure 3.3 – Example of a three-dimensional array

#37

If you want to create a three-dimensional array, you can use the following code:

int[,,] numbers = new int[3, 2, 3];

The remaining operations can be performed similarly as in the case of arrays with a different number of dimensions. Of course, you need to specify three indices while accessing a particular element of the array.

So far, you’ve learned about one-, two-, and three-dimensional arrays. But is it possible to use four-dimensional arrays? Of course!

#38

Imagine a four-dimensional array

Imagining a four-dimensional array is not very easy, but let’s try to do so! Once again, think about the three-dimensional game board we mentioned previously, but with content that changes depending on your level in the game. In this way, you can access a particular block in the three-dimensional world using X, Y, and Z coordinates. To get a target value, you need to use another dimension, namely by providing your current level. In this way, you will get different results depending on the fourth dimension. Not so difficult, right?

You can declare such an array using the following line of code:

int[,,,] numbers = new int[5, 4, 3, 2];

#39

If you need more dimensions, you can apply them. However, please keep in mind that using more dimensions can be quite difficult to understand and your code can be more difficult to follow and maintain in the future.

With this introduction to the topic of multi-dimensional arrays out of the way, let’s proceed to some examples. They will show you how to use such data structures in the real world.

#40

Example – multiplication table
This first example shows basic operations being performed on a two-dimensional array to present a multiplication table. It stores the results of the multiplication of all integer values in the range from 1 to 10 in the array and present them in the console:

 1   2   3   4   5   6   7   8   9  10
 2   4   6   8  10  12  14  16  18  20
 3   6   9  12  15  18  21  24  27  30
 4   8  12  16  20  24  28  32  36  40
 5  10  15  20  25  30  35  40  45  50
 6  12  18  24  30  36  42  48  54  60
 7  14  21  28  35  42  49  56  63  70
 8  16  24  32  40  48  56  64  72  80
 9  18  27  36  45  54  63  72  81  90
10  20  30  40  50  60  70  80  90 100

Let’s take a look at the declaration and initialization of the array:

int[,] results = new int[10, 10];

#41

Here, a two-dimensional array with 10 rows and 10 columns is created and its elements are initialized to default values – that is, to zeros. When the array is ready, you fill it with the results of the multiplication, as well as present the result in the console. Such a task can be performed using two for loops, as shown here:

for (int i = 0; i < results.GetLength(0); i++)
{
    for (int j = 0; j < results.GetLength(1); j++)
    {
        results[i, j] = (i + 1) * (j + 1);
        Console.Write($"{results[i, j],4}");
    }
    Console.WriteLine();
}

#42

In the preceding code, you can see the GetLength method, which is called on the results array. This method returns the number of elements in a particular dimension – that is, the first (when passing 0 as the parameter) and the second (1 as the parameter). In both cases, a value of 10 is returned, according to the values specified during the array’s initialization. Another important part of the code is the way of setting the value of an element. To do so, you must provide two indices.

#43

The multiplication results, after converting them into string values, have different lengths, from one character (as in the case of 4 as a result of 2*2) to three (100 from 10*10). To improve their presentation, you need to write each result in 4 characters. Therefore, if an integer value takes less space, leading spaces should be added. As an example, 1 will be shown with three leading spaces (___1, where _ is a space), while 100 will be shown with only one space (_100). You can achieve this goal by using a proper composite format string (namely, ,4) within the interpolated string.

#44

Example – game map
Another example is a program that presents a map of a game. This map is a rectangle with 6 rows and 8 columns. Each element of the array specifies a type of terrain as grass, sand, water, or brick (also referred to as wall). Each place on the map should be shown in a particular color (such as green for grass), as well as using a custom character that depicts the terrain type (such as ≈ for water), as shown in the following figure:

Figure 3.4 – Screenshot of the game map example

#45

Let’s start by creating two auxiliary methods that make it possible to get a particular color and character depending on the terrain’s type (GetColor and GetChar, respectively). The code for these methods is as follows:

ConsoleColor GetColor(char terrain)
{
    return terrain switch
    {
        'g' => ConsoleColor.Green,
        's' => ConsoleColor.Yellow,
        'w' => ConsoleColor.Blue,
        _ => ConsoleColor.DarkGray
    };
}
char GetChar(char terrain)
{
    return terrain switch
    {
        'g' => '\u201c',
        's' => '\u25cb',
        'w' => '\u2248',
        _ => '\u25cf'
    };
}

#46

As you can see, the code of the GetColor method is self-explanatory. However, the GetChar method returns a proper Unicode character depending on the character’s value (g, s, w, or b). For example, in the case of water, the '\u2248' value is returned, which is a representation of the ≈ character.

#47

Let’s take a look at the remaining part of the code. Here, you configure the map, as well as present it in the console. The code is as follows:
using System.Text;
char[,] map =
{
    { 's', 's', 's', 'g', 'g', 'g', 'g', 'g' },
    { 's', 's', 's', 'g', 'g', 'g', 'g', 'g' },
    { 's', 's', 's', 's', 's', 'b', 'b', 'b' },
    { 's', 's', 's', 's', 's', 'b', 's', 's' },
    { 'w', 'w', 'w', 'w', 'w', 'b', 'w', 'w' },
    { 'w', 'w', 'w', 'w', 'w', 'b', 'w', 'w' }
};
Console.OutputEncoding = Encoding.UTF8;
for (int r = 0; r < map.GetLength(0); r++)
{
    for (int c = 0; c < map.GetLength(1); c++)
    {
        Console.ForegroundColor = GetColor(map[r, c]);
        Console.Write(GetChar(map[r, c]) + " ");
    }
    Console.WriteLine();
}
Console.ResetColor(); 

#48

This code should not require additional comments or explanations. Just keep in mind that to use Unicode values in the console output, don’t forget to choose the UTF-8 encoding by setting the Encoding.UTF8 value for the OutputEncoding property. You can set the foreground color for the console using the ForegroundColor property. If you want to reset such a color to the default one, just call the ResetColor method, as presented in the last line.

So far, you’ve learned about both single- and multi-dimensional arrays, but one more variant remains to be presented in this book, namely jagged arrays. Let’s continue reading to learn more about them.

#49

Jagged arrays
The last variant of arrays to be described in this book is jagged arrays, also referred to as an array of arrays. It sounds complicated, but fortunately, it is very simple. A jagged array can be understood as a single-dimensional array, where each element is another array. Of course, such inner arrays can have different lengths or they can even be not initialized.


#50

Imagine a jagged array

If you want to better imagine a jagged array, stop reading this book for a moment, open your calendar, and switch its view so that it presents the whole year. It contains 365 or 366 boxes, depending on the year. For each day, you have a different number of meetings. On some days, you have three meetings, while on others, only one or even zero. Your holidays are marked in the calendar and blocked for meetings. You can easily imagine an application of a jagged array in this case. Each day box is an element of this array and it contains an array with data of meetings organized on a particular day. If this day is during your holidays, a related item is not initialized. This makes a jagged array much easier to visualize.

An example jagged array is presented in the following figure:

Figure 3.5 – Example of a jagged array

#51

This jagged array contains four elements. The first has an array with two elements (9 and 5). The second element has an array with three elements (0, -3, and 12). The third is not initialized (null), while the last one is an array with only one element (54).

Before proceeding to the example, it is worth mentioning the way of declaring and initializing a jagged array since it is a bit different from the arrays we’ve already described. Let’s take a look at the following code snippet:
int[][] numbers = new int[4][]; 
numbers[0] = new int[] { 9, 5 }; 
numbers[1] = new int[] { 0, -3, 12 }; 
numbers[3] = new int[] { 54 }; 

#52

This code can be simplified with a collection expression, as follows:

int[][] numbers = new int[4][];
numbers[0] = [9, 5];
numbers[1] = [0, -3, 12];
numbers[3] = [54];

In the first line, we declare a single-dimensional array with four elements. Each element is another single-dimensional array of integer values. When the first line is executed, the numbers array is initialized with default values, namely null. For this reason, we need to manually initialize particular elements, as shown in the following three lines of code. It is worth noting that the third element is not initialized.

#53

You can also write the preceding code in a different way, as shown here:

int[][] numbers =
{
    new int[] { 9, 5 },
    new int[] { 0, -3, 12 },
    null!,
    new int[] { 54 }
};

That’s not all – an even shorter variant is available:

int[][] numbers =
[
    [9, 5],
    [0, -3, 12],
    null!,
    [54]
];

#54

How can you access a particular element from a jagged array? Let’s see:

int number = numbers[1][2];
numbers[1][1] = 50;

The first line of code sets the value of the number variable to 12 – that is, to the value of the third element (index equal to 2) from the array, which is the second element of the jagged array. The other line changes the value of the second element within the array, which is the second element of the jagged array, from -3 to 50.

Now that we’ve introduced jagged arrays, let’s look at an example.

#55

Example – yearly transport plan
In this example, you’ll learn how to develop a program that creates a plan for your transportation for the whole year. For each day of each month, the application draws one of the available means of transport, such as by car, by bus, by subway, by bike, or simply on foot. In the end, the program presents the generated plan, as shown in the following screenshot:

Figure 3.6 – Screenshot of the yearly transport plan example

#56

First, let’s declare the enumeration type with constants representing types of transport:

public enum MeanEnum { Car, Bus, Subway, Bike, Walk }

The next part of the code is as follows:

Random random = new();
int meansCount = Enum.GetNames<MeanEnum>().Length;
int year = DateTime.Now.Year;
MeanEnum[][] means = new MeanEnum[12][];
for (int m = 1; m <= 12; m++)
{
    int daysCount = DateTime.DaysInMonth(year, m);
    means[m - 1] = new MeanEnum[daysCount];
    for (int d = 1; d <= daysCount; d++)
    {
        int mean = random.Next(meansCount);
        means[m - 1][d - 1] = (MeanEnum)mean;
    }
} 

#57

First, a new instance of the Random class is created. This will be used to draw a suitable means of transport from the available ones. In the next line, we get the number of available transport types. Then, the jagged array is created. It is assumed that it has 12 elements, representing all months in the current year.

#58

Next, a for loop is used to iterate through all the months within the year. In each iteration, the number of days is obtained using the DaysInMonth static method of DateTime. Each element of the jagged array is a single-dimensional array with MeanEnum values. The length of such an inner array depends on the number of days in a month. For instance, it is set to 31 elements for January and 30 elements for April.

#59

The next for loop iterates through all the days of the month. Within this loop, you draw a transport type and set it as a value of a suitable element within an array that is an element of the jagged array.

The next part of the code is related to presenting the plan in the console:
string[] months = GetMonthNames();
int nameLength = months.Max(n => n.Length) + 2;
for (int m = 1; m <= 12; m++)
{
    string month = months[m - 1];
    Console.Write($"{month}:".PadRight(nameLength));
    for (int d = 1; d <= means[m - 1].Length; d++)
    {
        MeanEnum mean = means[m - 1][d - 1];
        (char character, ConsoleColor color) = Get(mean);
        Console.ForegroundColor = ConsoleColor.White;
        Console.BackgroundColor = color;
        Console.Write(character);
        Console.ResetColor();
        Console.Write(" ");
    }
    Console.WriteLine();
} 

#60

First, a single-dimensional array with month names is created using the GetMonthNames method, which will be presented and described later. Then, a value of the nameLength variable is set to the maximum necessary length of text for storing the month name. To do so, the Max extension method is used to find the maximum length of text from the collection with names of months. The obtained result is increased by 2 to reserve space for a colon and a space.

#61

A for loop is used to iterate through all the elements of the jagged array – that is, through all months. In each iteration, the month’s name is presented in the console. The next for loop is used to iterate through all the items of the current element of the jagged array – that is, through all the days of the month. For each day, proper colors are set (for the foreground and background), and a suitable character is shown. Both a color and a character are returned by the Get method, taking the MeanEnum value as a parameter. This method will be shown a bit later.

#62

Now, let’s take a look at the implementation of the GetMonthNames method:
string[] GetMonthNames()
{
    CultureInfo culture = new("en");
    string[] names = new string[12];
    foreach (int m in Enumerable.Range(1, 12))
    {
        DateTime firstDay = new(DateTime.Now.Year, m, 1);
        string name = firstDay.ToString("MMMM", culture);
        names[m - 1] = name;
    }
    return names;
} 

This code is self-explanatory, but let’s focus on the line where we call the Range method. It returns a collection of integer values from 1 to 12. Therefore, we can use it together with the foreach loop, instead of a simple for loop iterating from 1 to 12. Just think about it as an alternative way of solving the same problem.


#63

Finally, it is worth mentioning the Get method. It allows us to use one method instead of two, namely returning a character and a color for a given transport type. By returning data as a value tuple, the code is shorter and simpler, as shown here:

(char Char, ConsoleColor Color) Get(MeanEnum mean)
{
    return mean switch
    {
        MeanEnum.Bike => ('B', ConsoleColor.Blue),
        MeanEnum.Bus => ('U', ConsoleColor.DarkGreen),
        MeanEnum.Car => ('C', ConsoleColor.Red),
        MeanEnum.Subway => ('S', ConsoleColor.Magenta),
        MeanEnum.Walk => ('W', ConsoleColor.DarkYellow),
        _ => throw new Exception("Unknown type")
    };
}

#64

Arrays are everywhere in this chapter! Now that we’ve learned about this data structure and its C# implementation-related topics, we can focus on some algorithms that are strictly related to arrays, namely sorting algorithms. Are you ready to get to know a few of them? If so, let’s proceed to the next section.

#65

Sorting algorithms
Many algorithms use arrays for a very broad range of applications. However, one of the most common tasks is sorting an array to arrange its elements in the correct order, either ascending or descending. Of course, you can sort data of various types, including numbers, strings, or even instances of user-defined classes. However, to keep things a bit simpler, here, we will only focus on sorting integer values.

#66

Imagine a sorting algorithm

You benefit from the sorting procedure frequently in your daily life! For example, your inbox is sorted in a way to present the newest messages first (by sending date in descending order), your calendar presents a day plan sorted by hours (by event start date in ascending order), as well as your list of tasks shows entries from the most important to the least important (by priority in descending order). That’s not all – at work, you sort documents by their issue date, then you choose a suitable road to home from the variants sorted by time to reach the destination, and in the evening, you change programs on the TV using a remote control according to the predefined order of channels.

#67

Sorting algorithms involve many approaches and are also a popular subject of research. There are a lot of sorting types, including selection sort, insertion sort, bubble sort, merge sort, Shell sort, quicksort, and heap sort. These will be explained in detail in this chapter. However, these are not all of the available approaches. Various types differ in their performance results, which is one of the most important aspects that you should take into account while choosing your sorting implementation. This topic will be analyzed at the end of this chapter to give you some tips in this area.

#68

Where can you find more information?

Array sorting is a popular topic that’s presented in various resources in books and research papers, as well as online. For example, you can read more about sorting algorithms presented in this chapter at Wikipedia, as well as you can take a look at some implementation codes at Wikibooks. You can browse for more information about the merge sort at https://en.wikipedia.org/wiki/Merge_sort and https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Merge_sort, about Shell sort at https://en.wikipedia.org/wiki/Shellsort and https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Shell_sort, about quicksort at https://en.wikipedia.org/wiki/Quicksort and https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort, and about heap sort at https://en.wikipedia.org/wiki/Heapsort and https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Heapsort. In a similar way, you can find information about other sorting algorithms. Of course, Wikipedia, together with Wikibooks, is not the only available source of content regarding such algorithms. There are a huge number of websites dedicated to this subject. Some of them also contain animations that show how various algorithms operate. This can help you visualize how they work.

#69

Selection sort
Let’s start with selection sort, which is one of the simplest sorting algorithms. This algorithm divides the array into two parts, namely sorted and unsorted. First, the sorted part is empty. In the following iterations, the algorithm finds the smallest element in the unsorted part and exchanges it with the first element in the unsorted part. Thus, the sorted part increases by one element. This sounds quite simple, doesn’t it?

#70

To better understand the selection sort algorithm, let’s take a look at the following iterations for an array with nine elements (-11, 12, -42, 0, 1, 90, 68, 6, and -9), as shown in the following figure:

Figure 3.7 – Illustration of the selection sort algorithm

#71

Bold lines are used to present the borders between the sorted and unsorted parts of the array. First (Step 1), the border is located just at the top of the array, which means that the sorted part is empty. Here, the algorithm finds the smallest value in the unsorted part (namely -42) and swaps it with the first element in this part (-11). The result is shown in Step 2, where the sorted part contains one element (-42), while the unsorted part consists of eight elements. In the next step, the algorithm finds -11 as the smallest value in the unsorted part and swaps it with 12, which is the first element in the unsorted part. As a result, the sorted part consists of two elements, namely -42 and -11, while the unsorted part contains only seven elements, as shown in Step 3. The aforementioned steps are performed a few times until only one element is left in the unsorted part. The final result is shown in Step 9.

#72

With that, you know how the selection sort algorithm works, but what role is performed by the i and m indicators shown on the left in the preceding diagram? They are related to the variables that are used in the implementation of this algorithm. So, it is time to see the code in the C# language!

The implementation is created within the Sort method, which takes the a array as the parameter and sorts it using selection sort:
void Sort(int[] a)
{
    for (int i = 0; i < a.Length - 1; i++)
    {
        int minIndex = i;
        int minValue = a[i];
        for (int j = i + 1; j < a.Length; j++)
        {
            if (a[j] < minValue)
            {
                minIndex = j;
                minValue = a[j];
            }
        }
        (a[i], a[minIndex]) = (a[minIndex], a[i]);
    }
}

#73

A for loop is used to iterate through the elements until only one item is left in the unsorted part. Thus, the number of iterations of the loop is equal to the length of the array minus one (a.Length - 1). In each iteration, another for loop is used to find the smallest value in the unsorted part (minValue, from the i + 1 index until the end of the array), as well as to store an index of the smallest value (minIndex, referred to as the m indicator in the preceding diagram). Finally, the smallest element in the unsorted part (with an index equal to minIndex) is swapped with the first element in the unsorted part (the i index).

#74

That’s all! Let’s use the following code to test the implementation of the selection sort algorithm:
int[] array = [-11, 12, -42, 0, 1, 90, 68, 6, -9];
Sort(array);
Console.WriteLine(string.Join(" | ", array));

#75

In the preceding code, an array is declared and initialized. Then, the Sort method is called, passing the array as a parameter. Finally, the string value is created by joining elements of the array, separated by |. The result is shown in the console:

-42 | -11 | -9 | 0 | 1 | 6 | 12 | 68 | 90

#76

Since we’re talking about various algorithms, one of the most important topics is computational complexity, especially time complexity. In the case of selection sort, both the worst and the average time complexity is O(n2). Why? Let’s take a look at the code to answer this question. There are two for loops (one within the other), each iterating through many elements of the array, which contains n elements. For this reason, the complexity is indicated as O(n2).

#77

A small reminder about computational complexity

You learned about computational complexity in the previous chapter. As a quick reminder, there are a few variants, such as for the worst or average case. This complexity can be interpreted as the number of basic operations that need to be performed by the algorithm, depending on the input size (n). The time complexity can be specified using Big O notation – for example, as O(n), O(n2), O(n log(n)) or O(1). As an example, the O(n) notation indicates that the number of operations increases linearly with the input size (n).

With that, you’ve learned about selection sort. If you are interested in another approach to sorting, proceed to the next section, where insertion sort is presented.

#78

Insertion sort
Insertion sort is another algorithm that makes it possible to sort a single-dimensional array simply. Here, the array is divided into two parts, namely sorted and unsorted. However, at the beginning, the first element is included in the sorted part. In each iteration, the algorithm takes the first element from the unsorted part and places it in a suitable location within the sorted part, to leave the sorted part in the correct order. Such operations are repeated until the unsorted part is empty.

As an example, let’s take a look at an illustration of sorting an array with nine elements (-11, 12, -42, 0, 1, 90, 68, 6, and -9) using insertion sort:


#79

Figure 3.8 – Illustration of the insertion sort algorithm

First, only one element (namely -11) is located in the sorted part (Step 1). Then, you take the first element from the unsorted part (12). In this case, the location of this element does not need to be changed, so the sorted part is increased to two elements, namely -11 and 12. Then, you take -42 as the first element in the unsorted part and you move it to the correct location in the sorted part. To do so, you need to perform two swap operations, as shown in Step 2. Thus, the length of the sorted part is increased to three elements, namely -42, -11, and 12. In Step 3, you take 0 as the first element from the unsorted part and perform one swap operation to place it in the correct position, just before 12, as presented in Step 4. At the same time, the size of the sorted part is increased to four already sorted elements, namely -42, -11, 0, and 12. Such operations are repeated until the unsorted part is empty (Step 9).

#80

The implementation code for the insertion sort algorithm is very simple:
void Sort(int[] a)
{
    for (int i = 1; i < a.Length; i++)
    {
        int j = i;
        while (j > 0 && a[j] < a[j - 1])
        {
            (a[j], a[j - 1]) = (a[j - 1], a[j]);
            j--;
        }
    }
}

#81

A for loop is used to iterate through all elements in the unsorted part. Thus, the initial value of the i variable is set to 1, instead of 0, because the unsorted part contains one element at the beginning. In each iteration of the for loop, a while loop is executed to move the first element from the unsorted part of the array (with the index equal to i) to the correct location within the sorted part, by swapping.

#82

Finally, it is worth mentioning the time complexity of the insertion sort algorithm. Similarly, as in the case of the selection sort, both the worst and average time complexity is O(n2). If you take a look at the code, you will see two loops (for and while) placed one within the other, which could iterate multiple times, depending on the input size (n).

#83

Bubble sort
The third sorting algorithm we’ll cover is bubble sort. Its way of operation is very simple. The algorithm just iterates through the array and compares adjacent elements. If they are located in an incorrect order, they are swapped. It sounds very easy, doesn’t it? Unfortunately, the algorithm is not efficient and its usage with large collections can cause performance-related problems.

#84

To better understand how the algorithm works, let’s take a look at the following figure, which shows how the algorithm operates in the case of sorting a single-dimensional array with nine elements (-11, 12, -42, 0, 1, 90, 68, 6, and -9):

#85

Figure 3.9 – Illustration of the bubble sort algorithm

In each step, the algorithm compares two adjacent elements in the array and swaps them, if necessary. For example, in Step 1, -11 and 12 are compared. They are placed in the correct order, so it is not necessary to swap such elements. In Step 2, the next adjacent elements are compared (namely 12 and -42). This time, such elements are not placed in the correct order, so they are swapped. The aforementioned operations are performed many times. Finally, the array is sorted, as shown in Step 72.

#86

The algorithm seems to be very easy, but what about its implementation? Is it also simple? Fortunately, yes! You just need to use two loops, compare adjacent elements, and swap them if necessary. That’s all! Let's take a look at the following code snippet:

void Sort(int[] a)
{
    for (int i = 0; i < a.Length; i++)
    {
        for (int j = 0; j < a.Length - 1; j++)
        {
            if (a[j] > a[j + 1]) 
            {
                (a[j], a[j + 1]) = (a[j + 1], a[j]);
            }
        }
    }
}

#87

Here, two for loops are used, together with a comparison and swapping. As mentioned previously, this algorithm is not efficient and its application can cause problems related to performance, especially in the case of large collections of data. However, it is possible to use a bit more efficient version of the bubble sort algorithm by introducing a simple modification. It is based on the assumption that comparisons should be stopped when no changes are discovered during one iteration through the array. The code is as follows:
void Sort(int[] a)
{
    for (int i = 0; i < a.Length; i++)
    {
        bool isAnyChange = false;
        for (int j = 0; j < a.Length - 1; j++)
        {
            if (a[j] > a[j + 1])
            {
                isAnyChange = true;
                (a[j], a[j + 1]) = (a[j + 1], a[j]);
            }
        }
        if (!isAnyChange) { break; }
    }
}

#88

By introducing such a simple modification, the number of steps can decrease. In the preceding example, it decreases from 72 steps to 56 steps.

Before moving on to the next sorting algorithm, it is worth mentioning the time complexity of the bubble sort algorithm. As you may have already guessed, both worst and average cases are the same as in the case of the selection and insertion sort algorithms – that is, O(n2).

#89

Merge sort
The fourth sorting algorithm operates in a significantly different way than the three already presented. This approach is named merge sort. This algorithm recursively splits the array in half until the array contains only one element, which is sorted. Then, the algorithm merges the already sorted subarrays (starting with these with only one element) into the sorted array. Finally, the whole array is sorted and the algorithm stops its operation.

To better understand the merge sort algorithm, let’s take a look at the following iterations for an array with six elements (-11, 12, -42, 0, 90, and -9):

Figure 3.10 – Illustration of the merge sort algorithm

#90

First (Step 1), you have the whole unsorted array, which you split into two parts, namely (-11, 12, -42) and (0, 90, -9), as shown in Step 2. In the next step, each of these subarrays is further split into (-11), (12, -42), (0), and (90, -9). In Step 4, you have the whole array divided into the subarrays with only one element each, namely (-11), (12), (-42), (0), (90), and (-9). Next, you merge all of these subarrays, together with sorting. Thus, in Step 5, you have three subarrays – that is, (-11, 12), (-42, 0), and (-9, 90). Please keep in mind that these subarrays are already sorted. In Step 6, you need to merge and sort them further into (-42, -11, 0, 12) and (-9, 90). Finally, you have the whole array sorted, namely (-42, -11, -9, 0, 12, 90).

#91

Does this seem simpler than just reading the textual description of the algorithm? If so, let’s proceed to its implementation:

void Sort(int[] a)
{
    if (a.Length <= 1) { return; }
    int m = a.Length / 2;
    int[] left = GetSubarray(a, 0, m - 1);
    int[] right = GetSubarray(a, m, a.Length - 1);
    Sort(left);
    Sort(right);
    int i = 0, j = 0, k = 0;
    while (i < left.Length && j < right.Length)
    {
        if (left[i] <= right[j]) { a[k] = left[i++]; }
        else { a[k] = right[j++]; }
        k++;
    }
    while (i < left.Length) { a[k++] = left[i++]; }
    while (j < right.Length) { a[k++] = right[j++]; }
}

#92

The Sort method is called recursively and takes the array that needs to be sorted as the parameter, named a. To stop infinitely calling this method recursively, you must specify the stop condition at the beginning. It simply checks whether the size of the array is not greater than 1. It is related to the assumption that you cannot further divide an array with one element only, because it is already sorted.

#93

Next, you calculate an index of the middle element and store it as a value of m. In the following two lines, you call the auxiliary GetSubarray method, which creates a new array with only a part of elements, either from its left-hand side (with indices from 0 to m-1, stored as left) or the right-hand side (from m to the length of the array minus 1, stored as right). You will see its implementation after the explanation of the Sort method. Coming back to the explanation of the Sort method, you then recursively call the Sort method, passing the left and right subarrays.

#94

The remaining part of the code is related to merging subarrays into the whole sorted array. Of course, this procedure is performed step by step, merging the subarrays into bigger and bigger subarrays until the whole array is sorted. You use a while loop to iterate through the left and right subarrays. You use three auxiliary variables, namely i as an index of the currently analyzed element from the left array, j from the right array, and k from the a array. Initially, all of them are set to 0, so you keep an eye on the first element of the left, right, and a arrays.

#95

Within the while loop, you check whether the current element from the left array (with the i index) is not greater than the current element from the right array (with the j index). If so, you place the current element from the left array as the first element in the a array. You also increase the i index, which means that the second element from the left array is the current one. If this condition is not met – that is, the current element from the right array is smaller than the current element from the left array – you use the current element from the right array as the first element in the a array and increase the j index. Finally, you increase the k index to keep an eye on the second element from the a array. The while loop ends when you are out of bounds of either the left or right array.

#96

What about when some elements haven’t been analyzed yet from the left or right arrays? To handle such cases, you use two additional while loops. These allow you to place the remaining elements from either the left or right array on the remaining places in the a array. As you can see, the Sort method is equipped with a very simple way of merging two arrays into one, together with their sorting.

#97

While explaining the algorithm’s implementation, the GetSubarray auxiliary method was mentioned. So, let’s show its code, together with a short explanation:

int[] GetSubarray(int[] a, int si, int ei)
{
    int[] result = new int[ei - si + 1];
    Array.Copy(a, si, result, 0, ei - si + 1);
    return result;
}


#98

This method uses the Copy static method of the Array class to copy a part of the source array (a) to the declared and initialized here destination array (result). To perform this task, you need to take the correct number of elements, namely ei – si + 1. Here, ei stands for end index and si stands for start index. You need to copy elements between arrays starting with the si index in the source array (a) and store them starting from the 0 index in the destination array (result).


#99

Of course, you can fill a subarray in different ways, such as using a for loop, which iterates through elements and copies them accordingly. If you want, you can prepare the alternative implementation on your own and then compare it during the performance tests, which you will see later in this chapter.

#100

What about the time complexity? It’s not very easy to specify it in the case of the merge sort algorithm compared to the other sorting algorithms I’ve presented. However, its time complexity is much better and can be indicated as O(n log(n)) for both average and worst cases. You will see what this means in practice while analyzing the performance results.

However, you still have some algorithms to learn about, so let’s proceed to the next one.

#101

Shell sort
A different approach to sorting is used in the Shell sort algorithm, whose name comes from its author’s name. It is a variation of the already presented insertion sort. The algorithm performs h-sorting to sort virtual subarrays consisting of elements with a distance equal to h, using the insertion sort. At the beginning, h is set to half of the array’s length and is divided by 2 in each iteration, until it is equal to 1. This description can seem a bit complicated, but it is a surprisingly efficient algorithm with a very simple implementation.

First, let’s take a look at a figure that should make this topic much simpler and easier to understand than just the plain text:

Figure 3.11 – Illustration of the Shell sort algorithm


#102

As the source array contains 7 elements, the initial h value is set to 3. So, now, it is time for 3-sorting. You create virtual subarrays with elements whose indices differ by 3. This means that the following indices are used: (0, 3, 6), (1, 4), and (2, 5). The first virtual subarray consists of (-11, -15, -13), so you sort it and receive (-15, -13, -11). The second is (12, -4) and forms (-4, 12) after sorting. The last is (13, -9) and is sorted into (-9, 13). When 3-sorting is completed, you calculate the next h value, simply by dividing the current value by 2. The result is 1 and it is also the last h-sorting iteration, namely 1-sorting. Now, you perform a simple insertion sort.

#103

The illustration and description look pretty simple, don’t they? Let's write some C# code to implement the Shell sort algorithm, as shown below:
void Sort(int[] a)
{
    for (int h = a.Length / 2; h > 0; h /= 2)
    {
        for (int i = h; i < a.Length; i++)
        {
            int j = i;
            int ai = a[i];
            while (j >= h && a[j - h] > ai)
            {
                a[j] = a[j - h];
                j -= h;
            }
            a[j] = ai;
        }
    }
}

The implementation consists of three loops. The first for loop is used to calculate proper values of h, starting with the array (a) length divided by 2. It is further divided by 2 after each iteration and the last acceptable value is 1.


#104

The next for loop calculates the i index, starting with h, and increases it until the end of the array is reached. This part is used to perform the insertion sort on virtual subarrays.

Within the loop, you can use the ai variable to store the current value of the element with the i index, so you can replace it later with another value. Then, a while loop is used to shift elements in the virtual subarray to find the correct location for ai. Finally, you store the ai variable in the location indicated by the j variable.

#105

As you can see, the implementation is very short and quite simple. What’s more, this algorithm is efficient and can be used for sorting large collections of data, as you will see later in this chapter. But what about the time complexity? In the worst case, it is O(n2). However, its average time complexity is about O(n log(n)).

#106

Quicksort
The sixth sorting algorithm described in this book is quicksort. It is one of the popular algorithms from the divide and conquer group and divides a problem into a set of smaller ones. How does it work?

The algorithm picks some value (for example, from the last element of the array) as a pivot. Then, it reorders the array in such a way that values lower than the pivot are placed before it (forming the lower subarray), while values greater than or equal to the pivot are placed after it (the higher subarray). Such a process is called partitioning. Next, the algorithm recursively sorts each of the aforementioned subarrays. Each subarray is further divided into the next two subarrays, and so on. The recursive calls stop when there are one or zero elements in a subarray because in such a case, there is nothing to sort.


#107

The preceding description may sound a bit complicated. However, the following figure and the algorithm’s implementation should remove any doubts.

The following diagram shows how the quicksort algorithm sorts a single-dimensional array with nine elements (-11, 12, -42, 0, 1, 90, 68, 6, and -9):

Figure 3.12 – Illustration of the quicksort algorithm

#108

In our case, it is assumed that the pivot is chosen as a value of the last element of the subarray that is currently being sorted. In Step 1, -9 is chosen as the pivot. Then, it is necessary to swap 12 with -42 (Step 1), as well as 12 with -9 (Step 2), to ensure that only values lower than the pivot (-11, -42) are in the lower subarray and only values greater than or equal to the pivot (0, 1, 90, 68, 6, 12) are placed in the higher subarray (Step 3). Then, the algorithm is called recursively for both aforementioned subarrays, namely (-11, -42, from Step 4) and (0, 1, 90, 68, 6, 12, from Step 7), so that they are processed in the same way as the input array.

#109

As an example, Step 7 shows that 12 is chosen as the pivot. After partitioning, the subarray is divided into two other subarrays, namely (0, 1, 6) and (90, 68). For both, other pivot elements are chosen, namely 6 and 68. After performing such operations for all the remaining parts of the array, you receive the result shown in Step 16.

#110

It is worth mentioning that the pivot can be selected variously in other implementations of this algorithm. Now that you understand how the algorithm works, let’s proceed to its implementation. It’s no more complicated than the examples shown earlier, and it uses recursion to call the sorting method for subarrays. The main code is as follows:
void Sort(int[] a)
{
    SortPart(a, 0, a.Length - 1);
}


#111

The Sort method takes only one parameter, namely the array that should be sorted. It just calls the SortPart method, which makes it possible to specify the lower and upper indices, which indicate which part of the array should be sorted. The code of the SortPart method is shown here:
void SortPart(int[] a, int l, int u)
{
    if (l >= u) { return; }
    int pivot = a[u];
    int j = l - 1;
    for (int i = l; i < u; i++)
    {
        if (a[i] < pivot)
        {
            j++;
            (a[j], a[i]) = (a[i], a[j]);
        }
    }
    int p = j + 1;
    (a[p], a[u]) = (a[u], a[p]);
    SortPart(a, l, p - 1);
    SortPart(a, p + 1, u);
}


#112

First, the method checks whether the array (or subarray) has at least two elements by comparing the values of the l (lower index) and u (upper index) variables. If not, you return from this method. Otherwise, you perform the partitioning phase.

#113

Here, the pivot is chosen as a value of the last element in the array (or subarray) and stored as a value of the pivot variable. Then, a for loop is used to rearrange the array using comparisons and swapping elements. You need to perform this stage to ensure that values lower than the pivot are placed before it, while values greater than or equal to the pivot are placed after it.

#114

Finally, you store a new index of the pivot value as p and perform swapping to place it there. The p variable is also used to calculate lower and upper bounds for subarrays, namely as (l, p-1) and (p+1, u). Such ranges are then used while calling the SortPart method recursively for the lower and upper parts. That’s all!

What about the time complexity? It has O(n log(n)) average time complexity, despite having O(n2) worst time complexity. Does this look similar to Shell sort to you? If so, you are right! You are coming closer and closer to the end of this chapter, where you will see results from conducting performance tests on various sorting algorithms.

#115

Heap sort
The last approach we’ll cover is based on an interesting data structure known as a binary heap. To give you a brief introduction, it is a tree-based structure where each node contains either zero, one, or two child nodes. You’ll learn more about trees and their variants later in this book.

#116

It won’t come as a surprise to you that the sorting solution is named heap sort. First, the algorithm builds a max-heap from the array (the heapify operation). Then, it repeats a few steps until there is only one element in the heap:

1.Swap the first element (root with the maximum value) with the last element.
2.Remove the last element (which is currently the maximum value) from the heap.
3.Build the max-heap again.

#117

By performing these operations, you efficiently receive the sorted array.

As a new data structure must be introduced here, let’s look at what the binary heap looks like and how the algorithm operates to sort the example array:

Figure 3.13 – Illustration of the heap sort algorithm

The input array consists of six elements, namely -11, 12, -42, 0, 90, and -9. You form a binary heap from it by placing the first element as a root and then by adding two of its child nodes: 12 and -42. You do not have more space at this level of the heap, so let’s add the following two elements from the array (0 and 90) as child nodes to the node with 12. The last element from the array is left. You must place it as a child node of the node with -42. As you can see, you can easily map an array to a binary heap data structure and use an array as a data structure to store the data of a binary heap.

#118

Interesting properties of a binary heap

Remember that a root node in a binary heap, represented by an array, is available at array[0]. If you need to access the data of a parent node of the i-th element, you can get it from array[(i-1)/2]. The left and right child nodes of the i-th element are available in array[(2*i)+1] and array[(2*i)+2], respectively.

#119

The next operation, which takes an important role in the heap sort algorithm, is named heapify. It can look a bit complicated, but after a short explanation, it should be clear. This operation aims to convert a binary heap into a max-heap. This means that each node can contain only the child nodes whose values are smaller than or equal to the node’s value. As an example, let’s take a look at the first row of the preceding figure. By using the heapify operation, 90 is located as the root. It contains 12 and -9 as nodes. The node with 12 contains child nodes with smaller values, namely 0 and -11. The node with -9 contains only one element, which is also smaller than it, namely -42.

#120

Max-heap is not the only option

You can also use the heapify operation to form the min-heap. It is similar to the max-heap, but each node needs to meet the condition that the values of its child nodes are greater than or equal to the parent node’s value.

Let’s proceed to the second row of the preceding figure. Here, the last element of the array (90) is already sorted. This is the result of swapping the root (previously, 90) with the last element in the array (previously, -42). Then, you must perform another heapify operation and receive the max-heap with 12 as the root. The aforementioned actions are repeated until the heap contains only one element. In the end, you receive the sorted array, as shown in the bottom-right corner of the preceding figure.

#121

At this point, you should be ready to analyze the implementation code in the C# language:

void Sort(int[] a)
{
    for (int i = a.Length / 2 - 1; i >= 0; i--)
    {
        Heapify(a, a.Length, i);
    }
    for (int i = a.Length - 1; i > 0; i--)
    {
        (a[0], a[i]) = (a[i], a[0]);
        Heapify(a, i, 0);
    }
}

The Sort method contains two for loops. The first performs the initial heapify operation to prepare the max-heap. You can do so by calling the Heapify multiple times, namely in reverse order and on each node that is not a leaf. Then, you have the array with data forming the max-heap.

#122

The second for loop is performed until there is at least one element in the heap. In each iteration, it swaps the root element (with an index equal to 0) with the last element, which has an index equal to i. Then, you need to restore the max-heap property, which you do by calling the Heapify method, regarding the affected part of the heap.

Now, let’s take a look at the code of the Heapify method:
void Heapify(int[] a, int n, int i)
{
    int max = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    max = l < n && a[l] > a[max] ? l : max;
    max = r < n && a[r] > a[max] ? r : max;
    if (max != i)
    {
        (a[i], a[max]) = (a[max], a[i]);
        Heapify(a, n, max);
    }
}

#123

It takes three parameters, namely an array (a), the number of elements in a heap (n), as well as an index of an element (i), which is a root of a subtree that should be heapified. First, you get an index of the maximum element (root, as max), as well as its left and right children (l and r, respectively). You can calculate indices according to the formulas presented earlier, namely 2*i+1 and 2*i+2.

#124

It takes three parameters, namely an array (a), the number of elements in a heap (n), as well as an index of an element (i), which is a root of a subtree that should be heapified. First, you get an index of the maximum element (root, as max), as well as its left and right children (l and r, respectively). You can calculate indices according to the formulas presented earlier, namely 2*i+1 and 2*i+2.

#125

In the following two lines, you check whether the left child index (l) is still within the heap (l<n) and whether the element with this index (a[l]) is greater than the current root value (a[max]). If so, you update the root index (max). In the same way, you check the right child and adjust the max variable, if necessary.

#126

In the next line, you check whether the root index changed during the mentioned operations. If so, this means that the current root is not the biggest value and you need to swap two elements in the array, namely representing the root (the i index) and the biggest value (the max index). Next, you recursively perform the heapify operation for the affected subtree, namely a tree with a new root value.

#127

After this detailed explanation, it is worth mentioning the time complexity. It is very important in this case because the method is efficient and can be used successfully while sorting large data collections. The time complexity is O(n log(n)).

Despite learning about seven different sorting algorithms, please keep in mind that there are many more such algorithms available, including block sort, tree sort, cube sort, strand sort, and cycle sort. If you are interested in this topic, I strongly encourage you to take a look at them on your own. In the meantime, let’s compare the algorithms we’ve covered in this chapter.

#128

Performance analysis
To perform some tests, you need to configure your environment. So, let’s start by preparing the code for running various sorting algorithms using the same input arrays.

Do you remember that each implementation presented in this chapter involves the Sort method, taking only one parameter (namely the a array)? Now, you can benefit from this assumption and create the AbstractSort abstract class, which requires you to implement this method while deriving from this class.

#129

The code for the abstract class is as follows:
public abstract class AbstractSort
{
    public abstract void Sort(int[] a);
}

Then, you need to prepare a separate class for each sorting algorithm (such as SelectionSort or HeapSort) according to the following template:

public class SelectionSort
    : AbstractSort
{
    public override void Sort(int[] a) { (...) }
}


#130

Since all the classes representing sorting algorithms derive from the base abstract class (AbstractSort)you can easily create a list containing their instances:
List<AbstractSort> algorithms = new()
{
    new SelectionSort(),
    new InsertionSort(),
    new BubbleSort(),
    new MergeSort(),
    new ShellSort(),
    new QuickSort(),
    new HeapSort()
};


#131

The most interesting part of the code is shown here:

for (int n = 0; n <= 100000; n += 10000)
{
    Console.WriteLine($"\nRunning tests for n = {n}:");
    List<(Type Type, long Ms)> milliseconds = [];
    for (int i = 0; i < 5; i++)
    {
        int[] array = GetRandomArray(n);
        int[] input = new int[n];
        foreach (AbstractSort algorithm in algorithms)
        {
            array.CopyTo(input, 0);
            Stopwatch stopwatch = Stopwatch.StartNew();
            algorithm.Sort(input);
            stopwatch.Stop();
            Type type = algorithm.GetType();
            long ms = stopwatch.ElapsedMilliseconds;
            milliseconds.Add((type, ms));
        }
    }
    List<(Type, double)> results = milliseconds
        .GroupBy(r => r.Type)
        .Select(r =>
            (r.Key, r.Average(t => t.Ms))).ToList();
    foreach ((Type type, double avg) in results)
    {
        Console.WriteLine($"{type.Name}: {avg} ms");
    }
}

#132

Here, you use a for loop to choose suitable values of n, which is the length of the input array used for sorting. You start with an array with zero elements (n = 0) and end with hundreds of thousands of elements (n = 100000), increasing the size by 10000 in each iteration. The values of n will be 0, 10000, 20000, and 30000, up to 100000.


#133

In each iteration, you create a new instance of the list (milliseconds) . Each its element stores a tuple consisting of two elements, namely a type of the sorting algorithm class (Type) and elapsed milliseconds of execution (Ms). Then, you use another for loop to perform such tests 5 times. In each of them, you get a random array (array) with a given size by calling GetRandomArray, which will be used as a template for each test. Next, you declare and initialize the input array (input).


#134

The next part involves a foreach loop and iterates through all instances of classes deriving from AbstractSort. For each of them, you create an input array by copying elements from array to input. Then, you start the stopwatch and call the Sort method. As soon as it has finished running, you stop the stopwatch and add results to the milliseconds list.

#135

The last part of the code is related to calculating the average result for each sorting algorithm and its presentation in the console. To do so, you use a few extension methods, such as GroupBy, Select, and Average, as well as a foreach loop.

The GetRandomArray method was mentioned earlier, so let’s take a look at it:
int[] GetRandomArray(long length)
{
    Random random = new();
    int[] array = new int[length];
    for (int i = 0; i < length; i++) 
    {
        array[i] = random.Next(-100000, 100000);
    }
    return array;
}

#136

It uses the Random class to get a random integer value in the range of <-100,000, 100,000). The whole array is filled with such random values.

At this point, your environment is ready and you can perform tests! So, let’s run the code and see the results. I received the following values:

#137

Figure 3.14 – Results of analyzing the performance of the sorting algorithms

Apart from the table and its data, let’s take a look at the chart:

#138

Figure 3.15 – Comparison of the sorting algorithms’ performance results

As you can see, the worst results are received for bubble sort, then the insertion sort and selection sort algorithms. For an array with 100,000 elements, they need almost 33 seconds (bubble sort), almost 14 seconds (insertion sort), and more than 5 seconds (selection sort). Such values look extremely high compared to the results of merge sort, Shell sort, quicksort, and heap sort. These algorithms needed between 12 and 28 milliseconds! Does this seem surprising? It shouldn’t if you recall time complexity.

#139

Let’s remember the average time complexity for the mentioned algorithms:

- O(n2): Selection sort, insertion sort, and bubble sort
- O(n log(n)): Merge sort, Shell sort, quicksort, and heap sort

Oh, so it seems that such time complexities really have an importance! ;-) If you earlier had any doubts, it’s the high time to take attention to the algorithms you use in your applications. You should choose them carefully and optimize the solution to handle various amounts of data that need to be processed.


#140

Don’t forget about performance

Taking care of performance is important not only for sorting but for all operations that you perform in your mobile applications, web applications, APIs, and long-running background services. Let’s try to write efficient code and test it not only by meeting the functional requirements but also by taking care of non-functional ones, such as those related to performance.

#141

In the previous chart, you almost cannot see any data regarding the algorithms with O(n log(n)) time complexity, so let’s prepare another set of tests. Now, you can choose only these algorithms and increase the maximum number of n to one million! You can see my results in the following chart:

#142

Figure 3.16 – Comparison of the sorting algorithms’ performance results

There are some differences here, especially between quicksort and the remaining ones, namely Shell sort, merge sort, and heap sort. However, such changes are only visible with quite a huge input size and can be caused by the implementation details. All of the sorting algorithms with O(n log(n)) time complexity are good solutions for sorting and can handle various amounts of data. It is also worth noting that these results were received on my device, so you may get different results. However, the relationship between the received number of elapsed milliseconds should be consistent.

