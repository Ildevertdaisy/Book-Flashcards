#1

Variants of Lists
In the previous chapter, you learned about arrays and their types. Of course, an array is not the only way of storing data. Another popular and even more powerful group of data structures contains various variants of lists. In this chapter, you will see such data structures in action, together with illustrations, explanations, and descriptions.

#2

First, you will see a simple list as an array list and a generic list, in which you can easily add and remove elements according to your needs. Then, you will get to know sorted lists, which keep an order of elements. Next, you will learn about four variants of the linked list, namely a singly linked list, a doubly linked list, a circular singly linked list, and a circular doubly linked list. Finally, you will familiarize yourself with three list-related interfaces that you can use while developing applications. Does this sound a bit complicated? If so, don’t worry. You will be guided throughout.

#3

We will cover the following topics in this chapter:

- Simple lists
- Sorted lists
- Linked lists
- List-related interfaces

#4

Simple lists
Arrays are really useful data structures and they are applied in many algorithms. However, in some cases, their application could be complicated due to their nature, which does not allow you to increase or decrease the length of the already-created array. What should you do if you do not know the total number of elements to store in the collection? Do you need to create a very big array and just not use unnecessary elements? Such a solution does not sound good, does it? A much better approach is to use a data structure that makes it possible to dynamically increase and decrease the size of the collection if necessary.

#5

Imagine a simple list

If you want to better visualize a simple list and distinguish it from an array, close your eyes for a moment and try to think back to when you were just a few years old and Christmas was approaching. You and your family were preparing a chain to hang on the Christmas tree. You took another piece of paper, passed it through the last piece of the chain, and glued the new piece of the chain together. In this way, your chain grew by another element, and you could add more and more elements to the chain, basically endlessly. Well, maybe the limitation was the amount of paper and glue or your tiredness. A list works somewhat similarly, where you can easily add new elements. You can also remove them, just like you can remove a piece of chain and then glue it back together and you can still hang it on your beautiful Christmas tree!

#6

Array lists
The first data structure that allows you to dynamically increase or decrease its size is the array list. It is represented by the ArrayList class from the System.Collections namespace. You can use this class to store big collections of data, to which you can easily add new elements when necessary. Of course, you can also remove them, count items, and find an index of a particular value stored within the array list. How can you do this? Let’s take a look at the following code:
using System.Collections;
ArrayList arrayList = new() { 5 };
arrayList.Add(6);
arrayList.AddRange(new int[] { -7, 8 });
arrayList.AddRange(new object[] { "Marcin", "Kate" });
arrayList.Insert(5, 7.8);

#7

In the first line, a new instance of the ArrayList class is created and 5 is added as the first element. This can be simplified, as shown here:

ArrayList arrayList = [5];

#8

Then, you use the Add, AddRange, and Insert methods to add new elements to the array list. The difference between them is as follows:

- Add adds a new item at the end of the list
- AddRange adds a collection of elements at the end of the array list
- Insert places an element in a specified location within the collection

#9

When the preceding code is executed, the array list contains the following elements: 5, 6, -7, 8, "Marcin", 7.8, and "Kate". Please keep in mind that all the items stored within the array list are of the object type. Thus, you can place various types of data in the same collection at the same time.

#10

Do you need to specify a type?

Using object instead of a particular type is not always a good idea. So, if you want to specify a type of each element stored within the list, you can use the generic List class, which will be described just after ArrayList. I encourage you to use a strongly typed version of a collection whenever possible.

#11

It is worth mentioning that you can easily access a particular element within the array list using an index, as shown in the following two lines of code:

object first = arrayList[0]!;
int third = (int)arrayList[2]!;

#12

Let’s take a look at casting to int in the second line. Such casting is necessary because the array list stores object values. As in the case of arrays, the zero-based indices are used while accessing particular elements within the collection. When you run the preceding lines of code, first will be equal to 5, while third will be equal to -7.


#13

Of course, you can use a foreach loop to iterate through all items, as follows:
foreach (object element in arrayList)
{
     Console.WriteLine(element);
}


#14

That’s not all – the ArrayList class has a set of properties and methods that you can use while developing applications utilizing the aforementioned data structure. To start with, let’s take a look at the Count and Capacity properties:
int count = arrayList.Count;
int capacity = arrayList.Capacity;

#15

The first property (Count) returns the number of elements stored currently in the array list, while the other property (Capacity) indicates how many elements can be stored within it. If you check the value of the Capacity property after adding new elements to the array list, you will see that this value is automatically increased to prepare a place for new items. This is shown in the following figure, which presents the difference between Count (marked as A) and Capacity (B):

Figure 4.1 – The difference between Count and Capacity

#16

The next common and important task is checking whether the array list contains an element with a particular value. You can perform this operation by calling the Contains method, as shown in the following line of code:
bool containsMarcin = arrayList.Contains("Marcin");

#17

If the specified value is found in the array list, true is returned. Otherwise, false is returned. But how can you find an index of this element? To do so, you can use the IndexOf or LastIndexOf method, as shown in the following line of code:
int minusIndex = arrayList.IndexOf(-7);

#18

The IndexOf method returns an index of the first occurrence of the element in the array list, while LastIndexOf returns an index of the last occurrence. If a value is not found, -1 is returned by the methods. Thus, you can use IndexOf to check whether the array list contains a given element. If the result is smaller than zero, this means that the element is not available. On the other hand, if the result is greater than or equal to zero, it indicates that the item is found, as presented in the following line:
bool containsAnn = arrayList.IndexOf("Ann") >= 0;

#19

Apart from adding some items to the array list, you can easily remove the already added elements using the Remove, RemoveAt, RemoveRange, and Clear methods, as shown here:
arrayList.Remove(5);
arrayList.RemoveAt(1);
arrayList.RemoveRange(1, 2);
arrayList.Clear();

#20

The difference between the mentioned methods is as follows:

- Remove removes the first occurrence of a given value
- RemoveAt removes an item with a provided index
- RemoveRange removes a given number of elements starting from some index
- Clear removes all elements

#21

Among other methods, it is worth mentioning Reverse, which reverses the order of the elements within the array list, as well as ToArray, which returns an array with all items stored in the ArrayList instance.

Where can you find more information?

You can find content regarding an array list at https://learn.microsoft.com/en-us/dotnet/api/system.collections.arraylist.

#22

Generic lists
As you can see, the ArrayList class contains a broad range of features, but it has a significant drawback – that is, it is not a strongly typed list. If you want to benefit from a strongly typed list, you can use the generic List class, which represents the collection whose size can be increased and decreased as necessary. This class is available in the System.Collections.Generic namespace.


#23

The generic List class contains many properties and methods that are useful while developing applications that store data. Many members are named the same as in the ArrayList class. An example is the following two properties:

- Count, which returns the current number of elements in the list
- Capacity, which indicates how many elements can be currently stored in the list

#24

There are also many similar methods, including the following ones:

- Add adds an item at the end of the list
- AddRange adds a collection of elements at the end of the list
- Insert places an element in a specified location within the list
- InsertRange places a collection of items in a specified location in the list
- Contains checks whether the list contains a given element
- IndexOf returns an index of the first occurrence of a given item
- LastIndexOf returns an index of the last occurrence of a given item
- Remove removes the first occurrence of a given value
- RemoveAt removes an item with a provided index
- RemoveRange removes a given number of elements starting from some index
- Clear removes all elements from the list
- Reverse reverses the order of items within the list
- ToArray returns an array with all items stored in the list

#25

You can get a particular element from the list using the [] operator with an index.

Apart from the already-described features, you can use a comprehensive set of extension methods from the System.Linq namespace. Some of them are as follows:
- Min finds the minimum value in the list
- Max finds the maximum value in the list
- Sum returns a sum of all elements in the list
- Average calculates the average value of elements in the list
- All checks whether all elements in the list satisfy a condition
- Any verifies whether at least one element in the list satisfies a condition
- ElementAtOrDefault returns an element at a given index in the collection or a default value if the index is out of bounds
- Distinct returns a collection with only unique elements, namely without duplicates
- OrderBy and OrderByDescending order all elements in the list in ascending or descending order, as well as return the ordered collection
- Skip returns a collection bypassing a given number of elements in the list
- Take returns a given number of elements from the list

#26

After this theoretical introduction, let’s see such methods in action! First, let’s get the minimum, maximum, sum, and average values from the list, as shown here:

List<int> list = [6, 90, -20, 0, 4, 1, 8, -20, 41];
int min = list.Min();
int max = list.Max();
int sum = list.Sum();
double avg = list.Average();

A value of min is equal to -20, max is equal to 90, sum is equal to 110, and avg is near 12.22.


#27

Now, let’s check out some conditions on the list elements:
bool allPositive = list.All(x => x > 0);
bool anyZero = list.Any(x => x == 0);

Here, allPositive is equal to false, while anyZero to true.

#28

The next part of the code is shown in the following block:
int existingElement = list.ElementAtOrDefault(5);
int nonExistingElement = list.ElementAtOrDefault(100);

#29

Here, you use the ElementAtOrDefault method to get a value of the element with an index equal to 5 and 100. In the first case, 1 is returned and stored as a value of the existingElement variable. When you try to get an element with the index equal to 100, a default value for int is used instead and returned, namely 0.


#30

The next extension method is named Distinct and can be used as follows:
List<int> unique = list.Distinct().ToList();


#31

It returns a unique collection of the IEnumerable<int> type, which you can convert into List<int> by calling the ToList extension method. The resulting list contains 6, 90, -20, 0, 4, 1, 8, and 41.

Let’s order the list using the OrderBy extension method, as follows:
List<int> ordered = list.OrderBy(x => x).ToList();

The target list consists of -20, -20, 0, 1, 4, 6, 8, 41, and 90.

#32

Another interesting group of methods consists of Skip and Take, as shown here:
List<int> skipped = list.Skip(4).ToList();
List<int> taken = list.Take(3).ToList();

The Skip method skips 4 elements and returns the collection with the remaining elements, namely 4, 1, 8, -20, and 41.

#33

The Take method simply takes 3 first elements – that is, 6, 90, and -20.

Do you have any idea how to combine Skip with Take in some real-world examples? If not, just think about the pagination mechanism, which you can find on many websites. It allows you to navigate between pages of data, where each page contains a specified number of elements. How you can get such items for a given page? The answer is as follows:
int page = 1;
int size = 10;
List<int> items = list
    .Skip((page - 1) * size)
    .Take(size)
    .ToList();

Of course, these are not the only features available for developers while creating applications using generic lists in the C# language. I strongly encourage you to discover more possibilities on your own. Next, we’ll look at two examples that show how to use a generic list in practice.

#34

Where can you find more information?

You can find content regarding a generic list at https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.

Example – average value
The first example utilizes the generic List class to store floating-point values (of the double type) entered by the user. After typing a number, the average value is calculated and presented in the console. The program stops the operation when an incorrect value is entered. The code is as follows:
List<double> num = [];
do
{
    Console.Write("Enter the number: ");
    string numStr = Console.ReadLine() ?? string.Empty;
    if (!double.TryParse(numStr, out double n)) { break; }
    num.Add(n);
    Console.WriteLine($"Average value: {num.Average()}");
}
while (true);

#35

First, an instance of the List class is created. Then, within the infinite loop (do-while), the program waits until the user enters a number. If it is correct, the entered value is added to the list (by calling Add), and an average value from elements in the list is calculated (by calling Average). The result is shown in the console:

Enter the number: 10.5
Average value: 10.5 (...)
Enter the number: 15.5
Average value: 9.375

In this section, you saw how to use a list that stores double values. However, can it also store instances of user-defined classes or records? Of course! You will see how to achieve this goal in the next example.


#36

Example – list of people
This second example shows you how to use a list to create a very simple database of people. For each, a name, an age, and a country are stored. When the program is launched, some data of people are added to the list. Then, such data is sorted and presented in the console.

Let’s start with the declaration of the Person record:
public record Person(string Name, int Age, string Country);


#37

The record contains three properties, namely Name, Age, and Country, which stores a country code. In the main part of the code, you create a new instance of the List class and add the data of a few people with different names, ages, and countries, as shown here:
List<Person> people =
[
    new("Marcin", 35, "PL"),
    new("Sabine", 25, "DE"),
    new("Mark", 31, "PL")
];

#38

In the next line, you sort the list by names of people in ascending order:
List<Person> r = people.OrderBy(p => p.Name).ToList();

#39

This line can be simplified using the collection expression, as follows:
List<Person> r = [.. people.OrderBy(p => p.Name)];

#40

Then, you iterate through all the results using a foreach loop:
foreach (Person p in r)
{
    string line = $"{p.Name} ({p.Age}) from {p.Country}.";
    Console.WriteLine(line);
}

After running the program, the following results will be presented:
Marcin (35) from PL.
Mark (31) from PL.
Sabine (25) from DE.

That’s all! Now, let’s talk a bit more about the LINQ expressions, which can be used not only to order elements but also to filter items based on the provided criteria, and even more.

#41

As an example, let’s take a look at the following query, which is using the method syntax:

List<string> names = people
    .Where(p => p.Age <= 30)
    .OrderBy(p => p.Name)
    .Select(p => p.Name)
    .ToList();

It selects the names (the Select clause) of all people whose age is lower than or equal to 30 years (the Where clause), ordered by names (the OrderBy clause). The query is then executed and the results are returned as a list (ToList).

#42

The same task can be accomplished using the query syntax, as shown in the following example, combined with calling the ToList method:
List<string> names = (from p in people
                      where p.Age <= 30
                      orderby p.Name
                      select p.Name).ToList(); 

#43

You saw how to use the ArrayList class and the generic List class to store data in collections, the size of which could be dynamically adjusted. However, this is not the end of list-related topics within this chapter. Are you ready to get to know another data structure that maintains the elements in the sorted order? If so, let’s proceed to the next section, which focuses on sorted lists.

#44

Sorted lists
So far, you’ve learned how to store data using simple lists. However, do you know that you can even use a data structure that ensures that the elements are sorted all the time? If not, let’s get to know the SortedList generic class (from the System.Collections.Generic namespace), which is a collection of key-value pairs, sorted by keys, without the necessity for you to sort them on your own. It’s worth mentioning that all keys must be unique and cannot be equal to null.

#45

Imagine a sorted list

If you want to imagine a sorted list, think about a business holder in which you put business cards that you have received from other people. Since you like order and want to always be able to quickly find a business card for a specific person, you make sure that they are all arranged in alphabetical order, by last name. What a terrible waste of time, especially if you have dozens of business cards and suddenly you have to put in a card for Mrs. Ana Ave. Oh, no... almost all the business cards have to be moved. What can help you at this point is a sorted list! On its basis, your magic business card holder works, which automatically inserts a new business card into the appropriate place in the business card holder. Thanks to this, you always have order and you do not have to waste time constantly taking out and inserting business cards. Congratulations!

#46

You can easily add an element to a sorted list using the Add method, as well as remove a specified item using the Remove method. Among other methods, it is worth noting ContainsKey and ContainsValue for checking whether the collection contains an item with a given key or value, as well as IndexOfKey and IndexOfValue for returning an index of an element by its key or value.

#47

As a sorted list stores key-value pairs, you have also access to the Keys and Values properties. Particular keys and values can be easily obtained using the [] operator together with an index. As you can see, this data structure is quite similar to the ones that have already been presented. However, it has some significant differences. So, let’s take a look at an example that will show you how to use this data structure. You will also see differences in code compared with the previously described List class.

Where can you find more information?

You can find content regarding a sorted list at https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2.

#48

Example – address book
This example uses the SortedList class to create a very simple address book, which is sorted by names of people. For each person, the following data is stored: Name, Street, PostalCode, City, and Country. The declaration of the Person record is shown in the following code:
public record Person(
    string Name,
    string Street,
    string PostalCode,
    string City,
    string Country);


#49

In the main part of the code, you create a new instance of SortedList. You need to specify types for keys and values, namely string and Person. Within the following part of the code, you also initialize the sorted list with data for Marcin and Martyna:
SortedList<string, Person> people = new()
{
    { "Marcin Jamro", new("Marcin Jamro",
      "Polish Street 1/23", "35-001", "Rzeszow", "PL") },
    { "Martyna Kowalska", new("Martyna Kowalska",
      "World Street 5", "00-123", "Warsaw", "PL") }
};


#50

Then, you can easily add data to the sorted list by calling the Add method, passing two parameters, namely a key (that is, a name), and a value (that is, an instance of the Person record), as shown in the following code snippet regarding Mark:
people.Add("Mark Smith", new("Mark Smith",
    "German Street 6", "10000", "Berlin", "DE"));

#51

When all the data is stored within the collection, you can easily iterate through its elements (namely through key-value pairs) using a foreach loop. It is worth mentioning that a type of the variable that’s used in the loop is KeyValuePair<string, Person>. However, you can use a value tuple to get access to a key (k) and a value (p):
foreach ((string k, Person p) in people)
{
    Console.WriteLine($"{k}: {p.Street}, {p.PostalCode}
        {p.City}, {p.Country}.");
}

#52

When the program is launched, you receive the following result in the console:
Marcin Jamro: Polish Street 1/23, 35-001 Rzeszow, PL.
Mark Smith: German Street 6, 10000 Berlin, DE.
Martyna Kowalska: World Street 5, 00-123 Warsaw, PL.

As you can see, the collection is automatically sorted by names, which are used as keys for the sorted list. However, you need to remember that keys must be unique, so you cannot add more than one person with the same full name in this example.

#53

Linked lists
While using the List generic class, you can easily get access to particular elements of the collection using indices. However, when you get a single element, how can you move to the next element of the collection? Is it possible? To do so, you may consider the IndexOf method to get an index of the element. Unfortunately, it returns an index of the first occurrence of a given value in the collection, so it will not always work as expected in this scenario. Fortunately, linked lists exist and can help you with this problem! In this section, you will learn about a few variants.

#54

Singly linked lists
A singly linked list is a data structure in which each list element contains a pointer to the next element. Thus, you can easily move from any element to the next one, but you cannot go back. Of course, the last element in the list has an empty pointer to the next element because there is nothing more located in the list.

#55

Imagine a singly linked list

If you want to better visualize a singly linked list, think about how to represent the phases of human development. Life after birth consists of the neonatal period, infancy, post-infanthood, preschool, school, adolescence, adulthood, and old age. From each phase, you can only go to the next one and you can never go back, even if you try very, very hard. It’s similar to a linked list, where you can easily move from a given item to the next item, but you don’t have any data to return to the item that brought you here. But it would be nice to be able to go back a dozen or so years and repeat some phase of development, right? Unfortunately, there is no “back” button here. :-)

Here’s an example of a singly linked list:

Figure 4.2 – Illustration of a singly linked list

Is it possible to further expand this data structure so that you can both go forward and backward from a given list element? Of course! Let’s take a look.

#56

Doubly linked lists
A doubly linked list is another data structure that allows you to navigate both forward and backward from each list item. It can be created based on the singly linked list by adding a second pointer, namely to the previous element.

#57

Imagine a doubly linked list

If you want to better imagine a doubly linked list, open a text editor and start describing your day in it. Whenever you make a mistake, you press the “undo” button and you see the earlier version. You can also press “redo” and suddenly, you see what was in the document just before you undone the changes. Of course, you can perform such an operation many times, and the system remembers many previous and next operations. This is how you can think of a doubly linked list. In each element of the list, you can easily go to both the next element (equivalent to a “redo” operation) and the previous element (equivalent to a “back” operation). Just look how easy it is to find applications for various data structures in everyday life!

The following figure illustrates a doubly linked list:

Figure 4.3 – Illustration of a doubly linked list


#58

As you can see, the FIRST box indicates the first element in the list. Each item has two properties that point to the previous and next element (PREV and NEXT, respectively). If there is no previous element, the PREV property is equal to null. Similarly, when there is no next element, the NEXT property is set to null. Moreover, the doubly linked list contains the LAST box that indicates the last element.

#59

Do you need to implement such a data structure on your own if you want to use it in your C#-based applications? Fortunately, no! It is already available as the LinkedList generic class in the System.Collections.Generic namespace. While creating an instance of this class, you need to specify the type parameter that indicates a type of a value stored in each element in the list, such as int or string. Each element (also referred to as a node) is represented by an instance of the LinkedListNode generic class, such as LinkedListNode<int> or LinkedListNode<string>.

#60

Some additional explanation is necessary for the methods of adding new nodes to the doubly linked list. For this purpose, you can use a set of methods:

- AddFirst adds an element at the beginning of the list
- AddLast adds an element at the end of the list
- AddBefore adds an element before the specified node in the list
- AddAfter adds an element after the specified node in the list

#61

All these methods return an instance of the LinkedListNode class. Moreover, there are some other methods:

- Contains checks whether the specified value exists in the list
- Remove removes a node from the list
- Clear removes all elements from the list

After this short introduction, let’s take a look at an example that shows how to apply the doubly linked list, implemented as the LinkedList class, in practice.

Where can you find more information?

You can find content regarding a linked list at https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1.

#62

Example – book reader
As an example, you will prepare a simple application that allows a user to read a book by changing pages. The user should be able to move to the next page (if it exists) after pressing the N key, and go back to the previous page (if it exists) after pressing the P key. The content of the current page, together with the page number, should be shown in the console, as presented in the screenshot:

#63

Figure 4.4 – Screenshot of the book reader example

Let’s start with a declaration of the Page record, as shown in the following code:
public record Page(string Content);

This record represents a single page and contains the Content property. Then, you create a few instances of the Page class, representing six pages of the book:
Page p1 = new("Welcome to (...)");
Page p2 = new("While reading (...)");
Page p3 = new("As a developer (...)");
Page p4 = new("In the previous (...)");
Page p5 = new("So far, you (...)");
Page p6 = new("The current (...)");


#64

When the instances have been created, you can construct the doubly linked list using a few addition-related methods, as shown in the following lines of code:
LinkedList<Page> pages = new();
pages.AddLast(p2);
LinkedListNode<Page> n4 = pages.AddLast(p4);
pages.AddLast(p6);
pages.AddFirst(p1);
pages.AddBefore(n4, p3);
pages.AddAfter(n4, p5);


#65

In the first line, a new empty list is created. Then, the given operations are performed:

1.Add the second page at the end ([2]).
2.Add the fourth page at the end ([2, 4]).
3.Add the sixth page at the end ([2, 4, 6]).
4.Add the first page at the beginning of the list ([1, 2, 4, 6]).
6.Add the third page before the fourth page ([1, 2, 3, 4, 6]).
7.Add the fifth page after the fourth page ([1, 2, 3, 4, 5, 6]).

#66

The next part of the code is responsible for presenting a page in the console, as well as for navigating between pages after pressing the appropriate keys. The code is as follows:
LinkedListNode<Page> c = pages.First!;
int number = 1;
while (c != null)
{
    Console.Clear();
    string page = $"- {number} -";
    int spaces = (90 - page.Length) / 2;
    Console.WriteLine(page.PadLeft(spaces + page.Length));
    Console.WriteLine();
    string content = c.Value.Content;
    for (int i = 0; i < content.Length; i += 90)
    {
        string line = content[i..];
        line = line.Length > 90 ? line[..90] : line;
        Console.WriteLine(line.Trim());
    }
    Console.WriteLine($"\nQuote from (...)");
    Console.Write(c.Previous != null
        ? "< PREV [P]" : GetSpaces(14));
    Console.Write(c.Next != null
        ? "[N] NEXT >".PadLeft(76) : string.Empty);
    Console.WriteLine();
    ConsoleKey key = Console.ReadKey(true).Key;
    if (key == ConsoleKey.N && c.Next != null)
    {
        c = c.Next;
        number++;
    }
    else if (key == ConsoleKey.P && c.Previous != null)
    {
        c = c.Previous;
        number--;
    }
}

#67

In the first line, the value of the c variable is set to the first node in the doubly linked list. Generally speaking, the c variable represents the page that is currently presented in the console. Then, the initial value for the page number is set to 1 (the number variable). However, the most interesting and complicated part of the code is shown in the while loop.

#68

Within the loop, the current content of the console is cleared and the string for presenting the page number is properly formatted to display. Before and after it, the - characters are added. Moreover, leading spaces are inserted (using the PadLeft method) to prepare the string that is centered horizontally.

#69

Then, the content of the page is divided into lines of no more than 90 characters and written in the console. To divide a string, the Length property and the range operator are used, such as in content[i..]. Similarly, additional information is presented in the console. Then, PREV and NEXT captions are shown, if a previous or a next page is available.

#70

Can you improve this example?

This example divides the text into a few lines while not taking spaces into account. I encourage you to modify the code so that it supports more user-friendly text wrapping. Good luck!

In the following part of the code, the program waits until the user presses any key and does not present it in the console (by passing true as a parameter of ReadKey). When the user presses N, the c variable is set to the next node, using the Next property. Of course, the operation should not be performed when the next page is unavailable. The P key is handled similarly, which causes the user to be navigated to the previous page. It is worth mentioning that the number of the page (the number variable) is modified alongside changing the value of the c variable.

#71

Finally, the code of the auxiliary GetSpaces method is shown:
string GetSpaces(int number) => string.Join(
    null, Enumerable.Range(0, number).Select(n => " "));

This prepares and returns the string variable with the specified number of spaces. Of course, there are several ways to perform this task. However, in this book, I wanted to show you various approaches, even those that are not so typical. The aim is to show you various ways of achieving your goal and making your horizons as broad as possible.

With this, you should be ready to continue your adventure regarding lists. In the next section, you’ll learn about circular lists and their two subtypes.


#72

Circular singly linked lists
In the previous two sections, you learned about linked lists. As you should remember, in a singly linked list, you can navigate between the nodes using the Next property. However, the Next property of the last node is set to null. Do you know that you can easily expand this approach to create a circular singly linked list, where the last node points to the first element, creating a list that can be iterated endlessly?

#73

Imagine a circular singly linked list

If you want to better imagine a circular singly linked list, think for a moment about a screensaver showing photos from a specific folder. After a certain period of inactivity, your screen starts showing photos, one after the other. When the last photo is displayed, the first one from the catalog is shown automatically. Of course, you can’t control the photos yourself, because any interaction with the keyboard or mouse turns off the screensaver. A circular singly linked list works similarly. Here, only information about the next list element is saved, without the possibility of going back. The last element of the list takes you to the very beginning. It’s so easy once you can imagine a real-life case, right? Now, move your mouse to make the screensaver disappear, and get back to learning more about data structures and algorithms!

The following figure illustrates a circular singly linked list:

#74

Figure 4.5 – Illustration of a circular singly linked list

After this short introduction to the topic of circular singly linked lists, it is time to take a look at the implementation code. As this data structure is not available by default while developing in C#, you will learn how to implement it on your own, based on a linked list. Let’s start with the following code snippet:
using System.Collections;
public class CircularLinkedList<T>
    : LinkedList<T>
{
    public new IEnumerator GetEnumerator() =>
        new CircularEnumerator<T>(this);
}

#75


The implementation can be created as a generic class that extends LinkedList, as shown in the preceding code. It is worth mentioning the implementation of the GetEnumerator method, which uses the CircularEnumerator class. By creating it, you will be able to endlessly iterate through all the elements of a circular linked list using a foreach loop. The code of CircularEnumerator is as follows:
public class CircularEnumerator<T>(LinkedList<T> list)
    : IEnumerator<T>
{
    private LinkedListNode<T>? _current = null;
    public T Current => _current != null
        ? _current.Value
        : default!;
    object IEnumerator.Current => Current!;
    public bool MoveNext()
    {
        if (_current == null)
        {
            _current = list?.First;
            return _current != null;
        }
        else
        {
            _current = _current.Next
                ?? _current!.List?.First;
            return true;
        }
    }
    public void Reset()
    {
        _current = null;
    }
    public void Dispose() { }
}

#76

The CircularEnumerator class implements the IEnumerator interface. This class declares the private field, which represents the current node (_current) in the iteration over the list. It also contains two properties, namely Current and IEnumerator.Current, which are required by the IEnumerator interface.

#77

One of the most important parts of the code is the MoveNext method. This checks whether the current element is equal to null. If so, it tries to get the first element from the list and starts iterating from it. If it does not exist, the method returns false since there are no items in the list. If the current element is not equal to null, it changes the current element to the next one or the first node in the list, if the next node is unavailable. In the Reset method, you just set a value of the _current field to null.

#78

Finally, you create the Next extension method that navigates to the first element while trying to get the next element from the last item in the list. To simplify the implementation, such a feature will be available as a method, instead of the Next property. The code is shown here:
public static class CircularLinkedListExtensions
{
    public static LinkedListNode<T>? Next<T>(
        this LinkedListNode<T> n)
    {
        return n != null && n.List != null
            ? n.Next ?? n.List.First
            : null;
    }
}

#79

The method checks whether the node exists and whether the list is available. In such a case, it returns a value of the Next property of the node (if such a value is not equal to null) or returns a reference to the first element in the list using the First property.

That’s all! You’ve just completed the C#-based implementation of a circular singly linked list that you can use in various applications. But how? Let’s take a look at the following example, which uses this data structure.

#80

Example – spin the wheel
This example simulates a game in which a user spins a wheel at a random speed. The wheel rotates slower and slower until it stops. Then, the user can spin it again, from the previous stop position, as shown in the following figure:

Figure 4.6 – Illustration of the spin the wheel example

#81

Let’s proceed to the first part of the code:
CircularLinkedList<string> categories = new();
categories.AddLast("Sport");
categories.AddLast("Culture");
categories.AddLast("History");
categories.AddLast("Geography");
categories.AddLast("People");
categories.AddLast("Technology");
categories.AddLast("Nature");
categories.AddLast("Science");

First, a new instance of the CircularLinkedList class is created, which represents a circular singly linked list with string elements. Then, eight values are added, namely Sport, Culture, History, Geography, People, Technology, Nature, and Science.

#82

The following part of the code performs the most important operations:
bool isStopped = true;
Random random = new();
DateTime targetTime = DateTime.Now;
int ms = 0;
foreach (string category in categories)
{
    if (isStopped)
    {
        Console.WriteLine("Press [Enter] to start.");
        ConsoleKey key = Console.ReadKey().Key;
        if (key == ConsoleKey.Enter)
        {
            ms = random.Next(1000, 5000);
            targetTime = DateTime.Now.AddMilliseconds(ms);
            isStopped = false;
            Console.WriteLine(category);
        }
        else { return; }
    }
    else
    {
        int remaining = (int)(targetTime
            - DateTime.Now).TotalMilliseconds;
        int waiting = Math.Max(100, (ms - remaining) / 5);
        await Task.Delay(waiting);
        if (DateTime.Now >= targetTime)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            isStopped = true;
        }
        Console.WriteLine(category);
        Console.ResetColor();
    }
}

#83

First, a few variables are declared:

- isStopped, which indicates whether the wheel is currently stopped
- random, for drawing random values of wheel spin in milliseconds
- targetTime, which is the target time when the wheel should stop
- ms, which is the last drawn number of milliseconds for wheel-spinning

#84

Then, the foreach loop is used to iterate through all the elements within a circular singly linked list. If there are no break or return instructions within such a loop, it will execute indefinitely due to the nature of a circular linked list. If the last item is reached, the first element in the list is taken automatically in the next iteration.

#85

In this loop, you check whether the wheel is currently stopped or has not been started yet. If so, the message is presented to the user and the program waits until the Enter key is pressed. In such a situation, the new spinning operation is configured by drawing the total time of spinning, setting the expected stop time, indicating that the wheel is not stopped, as well as writing the current category. When the user presses any other key, the program stops its execution.

#86

If the wheel is currently not stopped, you calculate the remaining number of milliseconds and the waiting time. This formula makes it possible to provide smaller times at the beginning (the wheel spins faster) and bigger times at the end (the wheel spins slower). Then, the program waits for the specified number of milliseconds.

#87

At the end, you check whether the target time is reached. If so, the foreground color is changed to red and you indicate that the wheel is stopped. Then, the currently chosen category on the spinning wheel is presented in the console.

When you run the application, you will get the result similar to the following one:

igure 4.7 – Screenshot of the spin the wheel example

With that, we’ve looked at an example that uses a circular singly linked list. Are you curious whether you can expand it further to create a circular doubly linked list?

#88

Circular doubly linked lists
The last data structure we’ll cover in this chapter is named the circular doubly linked list. It is similar to the circular singly linked list but allows you not only to iterate indefinitely in the forward direction but also in the backward direction. You can achieve this by adding pointers to previous elements for each item in the list. Of course, you also need to point to the last element in the list as the previous element of the first one in the list.

#89

Imagine a circular doubly linked list

If you want to better visualize a circular doubly linked list, grab your camera and start browsing the gallery of photos you’ve taken. Here, you can easily go from the first photo to the last one by clicking “back.” You can also go from the last photo to the first one by clicking “next.” Of course, you can also switch between subsequent photos in the photo gallery by clicking “back” and “next.” There is no issue with you taking another photo, at which point it will be added to the collection of photos you’ve already taken. Take a look for yourself! This is how a circular doubly linked list works. Snap, photo taken, and... let’s move on!

A circular doubly linked list is presented in the following diagram:

#90

Figure 4.8 – Illustration of a circular doubly linked list

Here, the PREV property of the first node navigates to the last one, while the NEXT property of the last node navigates to the first. This data structure can be useful in some specific cases, as you will see while developing a real-world example.

#91

After this short introduction to the topic of circular doubly linked lists, it is time to take a look at the implementation code. If you use the code that’s already been prepared for the circular singly linked list, you only need to add one extension method, as shown here:
public static class CircularLinkedListExtensions
{
    public static LinkedListNode<T>? Next<T>(
        this LinkedListNode<T> n)
    {
        return n != null && n.List != null
            ? n.Next ?? n.List.First
            : null;
    }
    public static LinkedListNode<T>? Prev<T>(
        this LinkedListNode<T> n)
    {
        return n != null && n.List != null
            ? n.Previous ?? n.List.Last
            : null;
    }
}


#92

The Prev method checks whether the node exists and whether the list is available. In such a case, it returns a value of the Previous property of the node (if such a value is not equal to null) or returns a reference to the last element in the list using the Last property. That’s all! Let’s take a look at the example.

#93

Example – art gallery
This example is a viewer of drawings presented in the console. Does this sound strange? It could be, but let’s try to create some console-based art!

Real art in the console exists!

The topic of creating console-based graphics is quite popular and some amazing art has already been created by various authors! If you are curious about this topic, just search for ASCII arts in your web browser. Will you join this community with your drawings? If so, please share them with me as well!

#94

When a user presses the right or left arrow, the drawing is changed to the next or the previous one, respectively. As a result, the following art can be viewed in the console:

Figure 4.9 – Screenshots of the art gallery example

The code uses the CircularLinkedList class, as shown here:
string[][] arts = GetArts();
CircularLinkedList<string[]> images = new();
foreach (string[] art in arts) { images.AddLast(art); }
LinkedListNode<string[]> node = images.First!;
ConsoleKey key = ConsoleKey.Spacebar;
do
{
    if (key == ConsoleKey.RightArrow)
    {
        node = node.Next()!;
    }
    else if (key == ConsoleKey.LeftArrow)
    {
        node = node.Prev()!;
    }
    Console.Clear();
    foreach (string line in node.Value)
    {
        Console.WriteLine(line);
    }
}
while ((key = Console.ReadKey().Key) != ConsoleKey.Escape);

#95

You create a circular doubly linked list consisting of a few elements. Each stores an array of strings. Such an array represents a particular image, namely the following rows forming the art. When you populate the list with data of all images, you store a reference to the first image as node. Then, you use a do-while loop that is executed until the Escape button is pressed. If the user presses the right arrow, you update the node variable using the Next method. If the left arrow is pressed, the Prev method is used instead. In each iteration, you clear the console and print the art so that you can receive a simple animation of a dancing figure.

#96

If you are curious how such images are defined, take a look at the following code:
string[][] GetArts() => [
    [
        "  +-----+  ",
        "o-| o o |-o",
        "  |  -  |  ",
        "  +-----+  ",
        "    | |    "
    ],
    [
        "o +-----+  ",
        " \\| o o |\\ ",
        "  |  -  | o",
        "  +-----+  ",
        "    / |    "
    ],
    [
        "  +-----+ o",
        " /| o o |/ ",
        "o |  -  |  ",
        "  +-----+  ",
        "    | \\    "
    ]
];

With that, you’ve learned how to use a circular doubly linked list. In the final section of this chapter, we’ll learn about three list-related interfaces.

#97

List-related interfaces
While developing applications in C#, you frequently use various collections, including lists. For this reason, it is worth mentioning three common interfaces:

- IEnumerable
- ICollection
- IList

#98

The order of them is important because IEnumerable is the base interface for ICollection and IList, while ICollection is the base interface for IList. However, what is inside such interfaces? Let’s take a look!

IEnumerable only provides you with a simple iteration over a collection. For this reason, it exposes the GetEnumerator method.

#99

The ICollection interface adds the following methods for manipulating the collection:

- Add adds a given item to the collection
- Clear removes all the items from the collection
- Contains checks whether a given item exists in the collection
- Remove removes the first occurrence of a given item from the collection

It also exposes the Count and IsReadOnly properties, as well as the CopyTo method for copying the collection to an array.


#100

The last interface I’ll mention here is IList. It allows you to access items within the collection by an index. Thus, the interface contains the indexer for getting or setting an item at a specified index in the collection, as well as methods:

- IndexOf returns an index of a given item in the collection
- Insert inserts a given item at a specified index in the collection
- RemoveAt removes an item at a specified index in the collection

#101

As an example, do you know that the LinkedList generic class implements both generic and non-generic variants of the ICollection and IEnumerable interfaces? I strongly encourage you to take a look at other collections to see what interfaces are implemented by them. You can see this by clicking on the collection name in your code (such as List or ArrayList) and choosing the Go To Definition option from the context menu or simply by pressing F12.

Where can you find more information?

You can find content regarding the mentioned interfaces at: https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable, https://learn.microsoft.com/en-us/dotnet/api/system.collections.icollection, and https://learn.microsoft.com/en-us/dotnet/api/system.collections.ilist.

Next, I’ll summarize this chapter.

