#1

Part II. A FastAPI Tour
The chapters in this part provide a thousand-foot view of FastAPI—more like a drone than a spy satellite. They cover the basics quickly but stay above the water line to avoid drowning you in details. The chapters are relatively short and are meant to provide context for the depths of Part III.

After you get used to the ideas in this part, Part III zooms into those details. That’s where you can do some serious good, or damage. No judgment; it’s up to you.


#2

Chapter 3. FastAPI Tour
FastAPI is a modern, fast (high-performance) web framework for building APIs with Python 3.6+ based on standard Python type hints.

Sebastián Ramírez, creator of FastAPI


#3

Preview
FastAPI was announced in 2018 by Sebastián Ramírez. It’s more modern in many senses than most Python web frameworks—taking advantage of features that have been added to Python 3 in the last few years. This chapter is a quick overview of FastAPI’s main features, with emphasis on the first things that you’ll want to know: how to handle web requests and responses.


#4

What Is FastAPI?
Like any web framework, FastAPI helps you build web applications. Every framework is designed to make some operations easier—by features, omissions, and defaults. As the name implies, FastAPI targets development of web APIs, although you can use it for traditional web content applications as well.


#5

The FastAPI website claims these advantages:

Performance
As fast as Node.js and Go in some cases, unusual for Python frameworks.

Faster development
No sharp edges or oddities.

Better code quality
Type hinting and models help reduce bugs.

Autogenerated documentation and test pages
Much easier than hand-editing OpenAPI descriptions.


#6

FastAPI uses the following:

- Python type hints

- Starlette for the web machinery, including async support

- Pydantic for data definitions and validation

- Special integration to leverage and extend the others

This combination makes a pleasing development environment for web applications, especially RESTful web services.



#7


A FastAPI Application
Let’s write a teeny FastAPI application—a web service with a single endpoint. For now, we’re in what I’ve called the Web layer, handling only web requests and responses. First, install the basic Python packages that we’ll be using:

- The FastAPI framework: pip install fastapi

- The Uvicorn web server: pip install uvicorn

- The HTTPie text web client: pip install httpie

- The Requests synchronous web client package: pip install requests

- The HTTPX synchronous/asynchronous web client package: pip install httpx

#8

Although curl is the best known text web client, I think HTTPie is easier to use. Also, it defaults to JSON encoding and decoding, which is a better match for FastAPI. Later in this chapter, you’ll see a screenshot that includes the syntax of the curl command line needed to access a particular endpoint.

#9

Let’s shadow an introverted web developer in Example 3-1 and save this code as the file hello.py.
Example 3-1. A shy endpoint (hello.py)
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi")
def greet():
    return "Hello? World?"


#10

Here are some points to notice:

- app is the top-level FastAPI object that represents the whole web application.

- @app.get("/hi") is a path decorator. It tells FastAPI the following:

    - A request for the URL "/hi" on this server should be directed to the following function.

    - This decorator applies only to the HTTP GET verb. You can also respond to a "/hi" URL sent with the other HTTP verbs (PUT, POST, etc.), each with a separate function.

- def greet() is a path function—the main point of contact with HTTP requests and responses. In this example, it has no arguments, but the following sections show that there’s much more under the FastAPI hood.


#11

The next step is to run this web application in a web server. FastAPI itself does not include a web server but recommends Uvicorn. You can start Uvicorn and the FastAPI web application in two ways: externally or internally.

To start Uvicorn externally, via the command line, see Example 3-2.

Example 3-2. Start Uvicorn with the command line
$ uvicorn hello:app --reload

The hello refers to the hello.py file, and app is the FastAPI variable name within it.


#12

Alternatively, you can start Uvicorn internally in the application itself, as in Example 3-3.

Example 3-3. Start Uvicorn internally
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi")
def greet():
    return "Hello? World?"

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("hello:app", reload=True)
In either case, that reload tells Uvicorn to restart the web server if hello.py changes. In this chapter, we’re going to use this automatic reloading a lot.


#13

Either case will use port 8000 on your machine (named localhost) by default. Both the external and internal methods have host and port arguments if you’d prefer something else.

Now the server has a single endpoint (/hi) and is ready for requests.

#14
Let’s test with multiple web clients:

- For the browser, type the URL in the top location bar.

- For HTTPie, type the command shown (the $ stands for whatever command prompt you have for your system shell).

- For Requests or HTTPX, use Python in interactive mode, and type after the >>> prompt.


#15


As mentioned in the Preface, what you type is in a

bold monospaced font
and the output is in a

normal monospaced font
Examples 3-4 through 3-7 show different ways to test the web server’s brand-new /hi endpoint.

Example 3-4. Test /hi in the browser
http://localhost:8000/hi


#16

Example 3-5. Test /hi with Requests
>>> import requests
>>> r = requests.get("http://localhost:8000/hi")
>>> r.json()
'Hello? World?'
Example 3-6. Test /hi with HTTPX, which is almost identical to Requests
>>> import httpx
>>> r = httpx.get("http://localhost:8000/hi")
>>> r.json()
'Hello? World?'



#17

NOTE
It doesn’t matter if you use Requests or HTTPX to test FastAPI routes. But Chapter 13 shows cases where HTTPX is useful when making other asynchronous calls. So the rest of the examples in this chapter use Requests.


#18

Example 3-7. Test /hi with HTTPie
$ http localhost:8000/hi
HTTP/1.1 200 OK
content-length: 15
content-type: application/json
date: Thu, 30 Jun 2022 07:38:27 GMT
server: uvicorn

"Hello? World?"
Use the -b argument in Example 3-8 to skip the response headers and print only the body.


#19

Example 3-8. Test /hi with HTTPie, printing only the response body
$ http -b localhost:8000/hi
"Hello? World?"
Example 3-9 gets the full request headers as well as the response with -v.

#20

Example 3-9. Test /hi with HTTPie and get everything
$ http -v localhost:8000/hi
GET /hi HTTP/1.1
Accept: /
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:8000
User-Agent: HTTPie/3.2.1



HTTP/1.1 200 OK
content-length: 15
content-type: application/json
date: Thu, 30 Jun 2022 08:05:06 GMT
server: uvicorn

"Hello? World?"
Some examples in this book show the default HTTPie output (response headers and body), and others show just the body.


#21

HTTP Requests
Example 3-9 included only one specific request: a GET request for the /hi URL on the server localhost, port 8000.

Web requests squirrel data in different parts of an HTTP request, and FastAPI lets you access them smoothly. From the sample request in Example 3-9, Example 3-10 shows the HTTP request that the http command sent to the web server.

Example 3-10. An HTTP request
GET /hi HTTP/1.1
Accept: /
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:8000
User-Agent: HTTPie/3.2.1


#22

This request contains the following:

- The verb (GET) and path (/hi)

- Any query parameters (text after any ? in this case, none)

- Other HTTP headers

- No request body content


#23

FastAPI unsquirrels these into handy definitions:

Header
The HTTP headers

Path
The URL

Query
The query parameters (after the ? at the end of the URL)

Body
The HTTP body

#24

NOTE
The way that FastAPI provides data from various parts of the HTTP requests is one of its best features and an improvement on how most Python web frameworks do it. All the arguments that you need can be declared and provided directly inside the path function, using the definitions in the preceding list (Path, Query, etc.), and by functions that you write. This uses a technique called dependency injection, which will be discussed as we go along and expanded on in Chapter 6.

#25

Let’s make our earlier application a little more personal by adding a parameter called who that addresses that plaintive Hello? to someone. We’ll try different ways to pass this new parameter:

- In the URL path

- As a query parameter, after the ? in the URL

- In the HTTP body

- As an HTTP header

#26

URL Path
Edit hello.py in Example 3-11.

Example 3-11. Return the greeting path
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi/{who}")
def greet(who):
    return f"Hello? {who}?"
Once you save this change from your editor, Uvicorn should restart. (Otherwise, we’d create hello2.py, etc. and rerun Uvicorn each time.) If you have a typo, keep trying until you fix it, and Uvicorn won’t give you a hard time.

#27

Adding that {who} in the URL (after @app.get) tells FastAPI to expect a variable named who at that position in the URL. FastAPI then assigns it to the who argument in the following greet() function. This shows coordination between the path decorator and the path function.

#28

NOTE
Do not use a Python f-string for the amended URL string ("/hi/{who}") here. The curly brackets are used by FastAPI itself to match URL pieces as path parameters.

In Examples 3-12 through 3-14, test this modified endpoint with the various methods discussed earlier.

Example 3-12. Test /hi/Mom in the browser
localhost:8000/hi/Mom
Example 3-13. Test /hi/Mom with HTTPie
$ http localhost:8000/hi/Mom
HTTP/1.1 200 OK
content-length: 13
content-type: application/json
date: Thu, 30 Jun 2022 08:09:02 GMT
server: uvicorn

"Hello? Mom?"

#29

Example 3-14. Test /hi/Mom with Requests
>>> import requests
>>> r = requests.get("http://localhost:8000/hi/Mom")
>>> r.json()
'Hello? Mom?'
In each case, the string "Mom" is passed as part of the URL, passed to the greet() path function as the who variable, and returned as part of the response.

The response in each case is the JSON string (with single or double quotes, depending on which test client you used) "Hello? Mom?".

#30

Query Parameters
Query parameters are the name=value strings after the ? in a URL, separated by & characters. Edit hello.py again in Example 3-15.

Example 3-15. Return the greeting query parameter
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi")
def greet(who):
    return f"Hello? {who}?"


#31

The endpoint function is defined as greet(who) again, but {who} isn’t in the URL on the previous decorator line this time, so FastAPI now assumes that who is a query parameter. Test with Examples 3-16 and 3-17.

Example 3-16. Test Example 3-15 with your browser
localhost:8000/hi?who=Mom
Example 3-17. Test Example 3-15 with HTTPie
$ http -b localhost:8000/hi?who=Mom
"Hello? Mom?"


#32

In Example 3-18, you can call HTTPie with a query parameter argument (note the ==).

Example 3-18. Test Example 3-15 with HTTPie and params
$ http -b localhost:8000/hi who==Mom
"Hello? Mom?"
You can have more than one of these arguments for HTTPie, and it’s easier to type these as space-separated arguments.

Examples 3-19 and 3-20 show the same alternatives for Requests.


#33

Example 3-19. Test Example 3-15 with Requests
>>> import requests
>>> r = requests.get("http://localhost:8000/hi?who=Mom")
>>> r.json()
'Hello? Mom?'
Example 3-20. Test Example 3-15 with Requests and params
>>> import requests
>>> params = {"who": "Mom"}
>>> r = requests.get("http://localhost:8000/hi", params=params)
>>> r.json()
'Hello? Mom?'
In each case, you provide the "Mom" string in a new way, and get it to the path function and through to the eventual response.


#34

Body
We can provide path or query parameters to a GET endpoint, but not values from the request body. In HTTP, GET is supposed to be idempotent—a computery term for ask the same question, get the same answer. HTTP GET is supposed to only return stuff. The request body is used to send stuff to the server when creating (POST) or updating (PUT or PATCH). Chapter 9 shows a way around this.


#35


So, in Example 3-21, let’s change the endpoint from a GET to a POST. (Technically, we’re not creating anything, so a POST isn’t kosher, but if the RESTful Overlords sue us, then hey, check out the cool courthouse.)

Example 3-21. Return the greeting body
from fastapi import FastAPI, Body

app = FastAPI()

@app.post("/hi")
def greet(who:str = Body(embed=True)):
    return f"Hello? {who}?"


#36

NOTE
That Body(embed=True) is needed to tell FastAPI that, this time, we get the value of who from the JSON-formatted request body. The embed part means that it should look like {"who": "Mom"} rather than just "Mom".


#37


Try testing with HTTPie in Example 3-22, using -v to show the generated request body (and note the single = parameter to indicate JSON body data).

Example 3-22. Test Example 3-21 with HTTPie
$ http -v localhost:8000/hi who=Mom
POST /hi HTTP/1.1
Accept: application/json, /;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: 14
Content-Type: application/json
Host: localhost:8000
User-Agent: HTTPie/3.2.1


{
    "who": "Mom"
}


HTTP/1.1 200 OK
content-length: 13
content-type: application/json
date: Thu, 30 Jun 2022 08:37:00 GMT
server: uvicorn

"Hello? Mom?"
And finally, test with Requests in Example 3-23, which uses its json argument to pass JSON-encoded data in the request body.

#38

Example 3-23. Test Example 3-21 with Requests
>>> import requests
>>> r = requests.post("http://localhost:8000/hi", json={"who": "Mom"})
>>> r.json()
'Hello? Mom?'


#39

HTTP Header
Finally, let’s try passing the greeting argument as an HTTP header in Example 3-24.

Example 3-24. Return the greeting header
from fastapi import FastAPI, Header

app = FastAPI()

@app.post("/hi")
def greet(who:str = Header()):
    return f"Hello? {who}?"
Let’s test this one just with HTTPie in Example 3-25. It uses name:value to specify an HTTP header.

#40

Example 3-25. Test Example 3-24 with HTTPie
$ http -v localhost:8000/hi who:Mom
GET /hi HTTP/1.1
Accept: */\*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:8000
User-Agent: HTTPie/3.2.1
who: Mom

HTTP/1.1 200 OK
content-length: 13
content-type: application/json
date: Mon, 16 Jan 2023 05:14:46 GMT
server: uvicorn

"Hello? Mom?"
FastAPI converts HTTP header keys to lowercase, and converts a hyphen (-) to an underscore (_). So you could print the value of the HTTP User-Agent header like this in Examples 3-26 and 3-27.

#41

Example 3-26. Return the User-Agent header (hello.py)
from fastapi import FastAPI, Header

app = FastAPI()

@app.post("/agent")
def get_agent(user_agent:str = Header()):
    return user_agent
Example 3-27. Test the User-Agent header with HTTPie
$ http -v localhost:8000/agent
GET /agent HTTP/1.1
Accept: */\*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:8000
User-Agent: HTTPie/3.2.1



HTTP/1.1 200 OK
content-length: 14
content-type: application/json
date: Mon, 16 Jan 2023 05:21:35 GMT
server: uvicorn

"HTTPie/3.2.1"


#42

Multiple Request Data
You can use more than one of these methods in the same path function. That is, you can get data from the URL, query parameters, the HTTP body, HTTP headers, cookies, and so on. And you can write your own dependency functions that process and combine them in special ways, such as for pagination or authentication. You’ll see some of these in Chapter 6 and in various chapters in Part III.


#43

Which Method Is Best?
Here are a few recommendations:

- When passing arguments in the URL, following RESTful guidelines is standard practice.

- Query strings are usually used to provide optional arguments, like pagination.

- The body is usually used for larger inputs, like whole or partial models.

In each case, if you provide type hints in your data definitions, your arguments will be automatically type-checked by Pydantic. This ensures that they’re both present and correct.

#44

HTTP Responses
By default, FastAPI converts whatever you return from your endpoint function to JSON; the HTTP response has a header line Content-type: application/json. So, although the greet() function initially returns the string "Hello? World?", FastAPI converts it to JSON. This is one of the defaults chosen by FastAPI to streamline API development.

#45

In this case, the Python string "Hello? World?" is converted to its equivalent JSON string "Hello? World?", which is the same darn string. But anything that you return is converted to JSON, whether built-in Python types or Pydantic models.

#46

Status Code
By default, FastAPI returns a 200 status code; exceptions raise 4xx codes.

In the path decorator, specify the HTTP status code that should be returned if all goes well (exceptions will generate their own codes and override it). Add the code from Example 3-28 somewhere in your hello.py (just to avoid showing the whole file again and again), and test it with Example 3-29.

Example 3-28. Specify the HTTP status code (add to hello.py)
@app.get("/happy")
def happy(status_code=200):
    return ":)"

#47

Example 3-29. Test the HTTP status code
$ http localhost:8000/happy
HTTP/1.1 200 OK
content-length: 4
content-type: application/json
date: Sun, 05 Feb 2023 04:37:32 GMT
server: uvicorn

":)"


#48

Headers
You can inject HTTP response headers, as in Example 3-30 (you don’t need to return response).

Example 3-30. Set the HTTP headers (add to hello.py)
from fastapi import Response

@app.get("/header/{name}/{value}")
def header(name: str, value: str, response:Response):
    response.headers[name] = value
    return "normal body"
Let’s see if it worked (Example 3-31).


#49

Example 3-31. Test the response HTTP headers
$ http localhost:8000/header/marco/polo
HTTP/1.1 200 OK
content-length: 13
content-type: application/json
date: Wed, 31 May 2023 17:47:38 GMT
marco: polo
server: uvicorn

"normal body"


#50


Response Types
Response types (import these classes from fastapi.responses) include the following:

JSONResponse (the default)

- HTMLResponse

- PlainTextResponse

- RedirectResponse

- FileResponse

- StreamingResponse

I’ll say more about the last two in Chapter 15.


#51

For other output formats (also known as MIME types), you can use a generic Response class, which needs the following:

content
String or bytes

media_type
The string MIME type

status_code
HTTP integer status code

headers
A dict of strings

#52


Type Conversion
The path function can return anything, and by default (using JSONResponse), FastAPI will convert it to a JSON string and return it, with the matching HTTP response headers Content-Length and Content-Type. This includes any Pydantic model class.

#53

But how does it do this? If you’ve used the Python json library, you’ve probably seen that it raises an exception when given some data types, such as datetime. FastAPI uses an internal function called jsonable_encoder() to convert any data structure to a “JSONable” Python data structure, then calls the usual json.dumps() to turn that into a JSON string. Example 3-32 shows a test that you can run with pytest.

#54

Example 3-32. Use jsonable_encoder() to avoid JSON kabooms
import datetime
import pytest
from fastapi.encoders import jsonable_encoder
import json

@pytest.fixture
def data():
    return datetime.datetime.now()

def test_json_dump(data):
    with pytest.raises(Exception):
        _ = json.dumps(data)

def test_encoder(data):
    out = jsonable_encoder(data)
    assert out
    json_out = json.dumps(out)
    assert json_out

#55

Model Types and response_model
It’s possible to have different classes with many of the same fields, except one is specialized for user input, one for output, and one for internal use. Some reasons for these variants could include the following:

- Remove some sensitive information from the output—like deidentifying personal medical data, if you’ve encountered Health Insurance Portability and Accountability Act (HIPAA) requirements.

- Add fields to the user input (like a creation date and time).

#56

Example 3-33 shows three related classes for a contrived case:

- TagIn is the class that defines what the user needs to provide (in this case, just a string called tag).

- Tag is made from a TagIn and adds two fields: created (when this Tag was created) and secret (an internal string, maybe stored in a database, but never supposed to be exposed to the world).

- TagOut is the class that defines what can be returned to a user (by a lookup or search endpoint). It contains the tag field from the original TagIn object and its derived Tag object, plus the created field generated for Tag, but not secret.


#57

Example 3-33. Model variations (model/tag.py)
from datetime import datetime
from pydantic import BaseClass

class TagIn(BaseClass):
    tag: str

class Tag(BaseClass):
    tag: str
    created: datetime
    secret: str

class TagOut(BaseClass):
    tag: str
    created: datetime
You can return data types other than the default JSON from a FastAPI path function in different ways. One method is to use the response_model argument in the path decorator to goose FastAPI to return something else. FastAPI will drop any fields that were in the object that you returned but are not in the object specified by response_model.

#58

In Example 3-34, pretend that you wrote a new service module called service/tag.py with the create() and get() functions that give this web module something to call. Those lower-stack details don’t matter here. The important point is the get_one() path function at the bottom, and the response_model=TagOut in its path decorator. That automatically changes an internal Tag object to a sanitized TagOut object.

Example 3-34. Return a different response type with response_model (web/tag.py)
import datetime
from model.tag import TagIn, Tag, TagOut
import service.tag as service

@app.post('/')
def create(tag_in: TagIn) -> TagIn:
    tag: Tag = Tag(tag=tag_in.tag, created=datetime.utcnow(),
        secret="shhhh")
    service.create(tag)
    return tag_in

@app.get('/{tag_str}', response_model=TagOut)
def get_one(tag_str: str) -> TagOut:
    tag: Tag = service.get(tag_str)
    return tag
Even though we returned a Tag, response_model will convert it to a TagOut.

#59

Automated Documentation
This section assumes that you’re running the web application from Example 3-21, the version that sends the who parameter in the HTTP body via a POST request to http://localhost:8000/hi.

Convince your browser to visit the URL http://localhost:8000/docs.

You’ll see something that starts like Figure 3-1 (I’ve cropped the following screenshots to emphasize particular areas).

#60

Figure 3-1. Generated documentation page
Where did that come from?

FastAPI generates an OpenAPI specification from your code, and includes this page to display and test all your endpoints. This is just one ingredient of its secret sauce.

Click the down arrow on the right side of the green box to open it for testing (Figure 3-2).

#61

Click that “Try it out” button on the right. Now you’ll see an area that will let you enter a value in the body section (Figure 3-3).

Click that "string". Change it to "Cousin Eddie" (keep the double quotes around it). Then click the bottom blue Execute button.

Now look at the Responses section below the Execute button (Figure 3-4).

The “Response body” box shows that Cousin Eddie turned up.

So, this is yet another way to test the site (besides the earlier examples using the browser, HTTPie, and Requests).


#62

Figure 3-4. Response page
By the way, as you can see in the Curl box of the Responses display, using curl for command-line testing instead of HTTPie would have required more typing. HTTPie’s automatic JSON encoding helps here.

TIP
This automated documentation is actually a big, furry deal. As your web service grows to hundreds of endpoints, a documentation and testing page that’s always up-to-date is helpful.


#63

Complex Data
These examples showed only how to pass a single string to an endpoint. Many endpoints, especially GET or DELETE ones, may need no arguments at all, or only a few simple ones, like strings and numbers. But when creating (POST) or modifying (PUT or PATCH) a resource, we usually need more complex data structures. Chapter 5 shows how FastAPI uses Pydantic and data models to implement these cleanly.

#64

Review
In this chapter, we used FastAPI to create a website with a single endpoint. Multiple web clients tested it: a web browser, the HTTPie text program, the Requests Python package, and the HTTPX Python package. Starting with a simple GET call, request arguments went to the server via the URL path, a query parameter, and an HTTP header. Then, the HTTP body was used to send data to a POST endpoint. Later, the chapter showed how to return various HTTP response types. Finally, an automatically generated form page provided both documentation and live forms for a fourth test client.

This FastAPI overview will be expanded in Chapter 8.

